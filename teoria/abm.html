<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TEMA 6</title>
  <meta name="author" content="Luciano Rabassa"/>
  <meta name="created" content="2026-02-01T21:32:00"/>
  <meta name="AppVersion" content="15.0000"/>
  <meta name="Company" content="Luciano's tech"/>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/prism.css">
</head>

<body>

<header class="site-header">
  <p class="materia">Informática II</p>
</header>

<main>
  <div class="container">
<h1>Archivos FILE *</h1>
<h3 class="tema">Parte 2</h3>
<h3 class="tema">Binarios, acceso aleatorio, bloques de memoria, ABM</h3>

<h2>Archivos binarios</h2>
<h3>¿Qué es un archivo binario?:</h3>
<ul>
    <li>No guarda texto legible.</li>
    <li>Guarda bytes tal cual están en memoria.</li>
    <li><b>Ideal para:</b>
    <ul>
        <li>struct</li>
        <li>arrays</li>
        <li>registros</li>
        <li>base de datos simples</li>
    </ul>
    </li>
</ul>

<h3>Ventaja:</h3>
<ul>
    <li>Más rápido.</li>
    <li>Más chico.</li>
    <li>No hay parsing.</li>
</ul>

<h3>Desventaja:</h3>
<ul>
    <li>No es portable entre arquitecturas distintas.</li>
    <li>No es legible a mano.</li>
</ul>

<h2>Modos binarios</h2>

<div class="tablecontainer">
<table>
    <tr>
        <th>Modo</th>
        <th>Significado</th>
    </tr>
    <tr>
        <td>"rb"</td>
        <td>leer binario</td>
    </tr>
    <tr>
        <td>"wb"</td>
        <td>escribir binario (borra)</td>
    </tr>
    <tr>
        <td>"ab"</td>
        <td>agregar</td>
    </tr>
    <tr>
        <td>rb+</td>
        <td>leer/escribir</td>
    </tr>
    <tr>
        <td>wb+</td>
        <td>leer/escribir (borra)</td>
    </tr>
</table>
</div>
<div class="nota">
    <p><strong>En Windows es obligatorio usar <code>b</code>.</strong></p>
</div>
    
<h2>Escritura de bloques</h2>
<pre><code class="language-c">fwrite</code></pre>

<h3>Sintaxis:</h3>
<pre><code class="language-c">size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *fp);</code></pre>

<h3>¿Qué hace?:</h3>
<ul>
    <li>Escribe nmemb elementos.</li>
    <li>Cada uno de tamaño size.</li>
    <li>Desde memoria &rArr; archivo.</li>
</ul>

<h3>Ejemplo:</h3>
<pre><code class="language-c">
int x = 42;
fwrite(&x, sizeof(int), 1, fp);
</code></pre>
<div class="nota">
    <p><strong>Escribe el <code>int</code> completo, no texto.</strong></p>
</div>

<h2>Lectura de bloques</h2>
<pre><code class="language-c">fread</code></pre>

<h3>Sintaxis:</h3>
<pre><code class="language-c">size_t fread(void *ptr, size_t size, size_t nmemb, FILE *fp);</code></pre>

<h3>¿Qué hace?:</h3>
<ul>
    <li>Lee nmemb elementos.</li>
    <li>Cada uno de tamaño size.</li>
    <li>Desde memoria &rArr; archivo.</li>
</ul>

<h3>Ejemplo:</h3>
<pre><code class="language-c">
int x;
fread(&x, sizeof(int), 1, fp);
</code></pre>
<div class="nota">
    <p><strong>Retorna cuantos elementos leyó realmente.</strong></p>
</div>
    
<h3>Ejemplo:</h3>
<ul>
    <li>struct + archivo binario</li>
</ul>

<h3>Definimos un registro:</h3>
<pre><code class="language-c">
typedef struct {
  int id;
  char nombre[30];
  float sueldo;
} Empleado;
</code></pre>
        
<h3>Escritura:</h3>
<pre><code class="language-c">
Empleado e = {1, "Linda", 120000.50};
-
FILE *fp = fopen("empleados.dat", "wb");
fwrite(&e, sizeof(Empleado), 1, fp);
fclose(fp);
</code></pre>

<h3>Lectura:</h3>
<pre><code class="language-c">
Empleado e;
-
FILE *fp = fopen("empleados.dat", "rb");
fread(&e, sizeof(Empleado), 1, fp);
fclose(fp);
-
printf("%d %s %.2f\n", e.id, e.nombre, e.sueldo);
</code></pre>
<div class="nota">
    <p><strong>No hay <code>fscanf</code>, no hay parsing, no hay texto.</strong></p>
</div>
    
<h3>Lectura/escritura de varios registros:</h3>
<pre><code class="language-c">
Empleado v[2] = {
  {1, "Linda", 100000},
  {2, "Jaime", 110000},
  {3, "Carlos", 105000}
};
-
fwrite(v, sizeof(Empleado), 3, fp);
</code></pre>

<h3>Lectura:</h3>
<pre><code class="language-c">
Empleado v[3];
fread(v, sizeof(Empleado), 3, fp);
</code></pre>
<div class="nota">
    <p><strong>Esto es memoria &rArr; disco &rArr; memoria, directo.</strong></p>
</div>
    
<h2>Acceso aleatorio</h2>
<ul>
    <li><code>fseek</code></li>
    <li><code>ftell</code></li>
    <li><code>rewind</code></li>
</ul>

<h3>Sintaxis <code>fseek</code>:</h3>
<pre><code class="language-c">int fseek(FILE *fp, long offset, int origen);</code></pre>

<div class="tablecontainer">
    <table>
        <tr>
            <th>Origen</th>
            <th>Significado</th>
        </tr>
        <tr>
            <td>SEEK_SET</td>
            <td>Inicio</td>
        </tr>
        <tr>
            <td>SEEK_CUR</td>
            <td>Posición actual</td>
        </tr>
        <tr>
            <td>SEEK_END</td>
            <td>Fin</td>
        </tr>
    </table>
</div>
             
<h3>Ejemplo:</h3>

<ul>
    <li>Ir al registro <strong>N</strong>.</li>
</ul>

<pre><code class="language-c">
fseek(fp, n * sizeof(Empleado), SEEK_SET);
fread(&e, sizeof(Empleado), 1, fp);
</code></pre>
<div class="nota">
    <p><strong>Esto es archivo random / directo.</strong></p>
</div>

<h3>Sintaxis <code>ftell</code>:</h3>

<pre><code class="language-c">long pos = ftell(fp);</code></pre>
<div class="nota">
    <p><strong>Devuelve la posición actual (en <code>bytes</code>).</strong></p>
</div>

<h3>Sintaxis <code>rewind</code>:</h3>

<pre><code class="language-c">rewind(fp);</code></pre>
<div class="nota">
    <p><strong>Vuelve al inicio (equivale a <code>fseek(fp, 0, SEEK_SET)</code> ).</strong></p>
</div>
        
<h2>Altas, Bajas y Modificaciones (ABM)</h2>

<h3>Alta:</h3>
<pre><code class="language-c">
fopen("ab")
fwrite
</code></pre>

<h3>Listado:</h3>
<pre><code class="language-c">
fopen("rb")
while (fread(...) == 1)
</code></pre>

<h3>Modificación:</h3>
<pre><code class="language-c">
fopen("rb+")
buscar registro
fseek
fwrite
</code></pre>

<h3>Baja lógica:</h3>
<ul>
    <li>No borra físicamente.</li>
    <li>Marca como borrado</li>
</ul>

<h3>Ejemplo:</h3>

<pre><code class="language-c">
typedef struct {
  int id;
  char nombre[30];
  float sueldo;
  int activo; // 1 = activo, 0 = borrado
} Empleado;
</code></pre>
    
<h2>Borrar un archivo:</h2>
<pre><code class="language-c">remove</code></pre>

<h3>Sintaxis remove:</h3>
<pre><code class="language-c">int remove(const char *filename);</code></pre>

<h3>¿Qué hace?:</h3>
<p>Borra un archivo del sistema (No del programa, <b>del disco</b>).</p>

<h3>Ejemplo:</h3>

<pre><code class="language-c">remove("empleados.dat");</code></pre>
<div class="nota">
    <p><strong>Borra el archivo del sistema.</strong></p>
</div>
    
<h2>Liberar buffer manualmente:</h2>
<pre><code class="language-c">fflush</code></pre>

<h3>Sintaxis:</h3>
<pre><code class="language-c">fflush(fp);</code></pre>
<ul>
    <li>Fuerza escritura inmediata.</li>
    <li>Util en logs.</li>
    <li>Normalmente no hace falta si usas <code>fclose</code>.</li>
</ul>
    
<h2>Conceptos teóricos:</h2>

<h3>Streams:</h3>
<p>Es un flujo de datos entre el programa y un dispositivo (Teclado, Pantalla, Archivo, etc).</p>

<p><b>Utiliza un buffer intermedio:</b></p>
    <ul>
        <li><b>En salida</b> <strong><code>stdout</code></strong>: se acumulan datos y luego se escriben.</li>
        <li><b>En entrada</b> <strong><code>stdin</code></strong>: se leen bloques desde el dispositivo.</li>
    </ul>
        
<h3>Streams estándar:</h3>
<ul>
    <li><strong><code>stdin  :</code></strong> entrada estándar (teclado)</li>
    <li><strong><code>stdout :</code></strong> salida estándar (pantalla)</li>
    <li><strong><code>stderr :</code></strong> salida de errores (pantalla)</li>
</ul>

<h3>En formato texto:</h3>
<ul>
    <li>Se realizan conversiones (<strong><code>ASCII</code></strong>)</li>
</ul>

<h3>En formato binario:</h3>
<ul>
    <li>No hay conversiones.</li>
    <li>Los datos se guardan tal cual en memoria.</li>
</ul>

<h3>struct FILE:</h3>
<ul>
    <li>
        <strong><code>FILE</code></strong> es una estructura opaca definida por la librería
        estándar que representa un stream de archivo.
    </li>
</ul>

<h4>Contiene internamente:</h4>
<ul>
    <li>Buffer.</li>
    <li>Posición actual.</li>
    <li>Flags de estado.</li>
    <li>Descriptor del sistema operativo.</li>
</ul>
        
<div class="nota">
    <h3>IMPORTANTE:</h3>
    <ul>
        <li>El contenido de <strong><code>FILE</code></strong> es dependiente del compilador.</li>
        <li>No debe accederse a sus campos directamente.</li>
        <li>Solo se manipula mediante funciones estándar (<strong><code>fopen</code></strong>, <strong><code>fread</code></strong>, <strong><code>fwrite</code></strong>, <strong><code>fseek</code></strong>, <strong><code>fclose</code></strong>, etc.)</li>
    </ul>
</div>


<h2 class="teoria">Teoría aplicada</h2>

<h3 class="make">Makefile:</h3>
<pre><code class="language-c">
CC = gcc
CFLAGS = -std=c11 -Wall -Wextra -pedantic

PROG = abm
OBJ = main.o

$(PROG): $(OBJ)
	$(CC) $(OBJ) -o $(PROG)

$(OBJ): main.c
	$(CC) $(CFLAGS) -c main.c

.PHONY: clean
clean:
	del $(OBJ) $(PROG).exe *.txt
</code></pre>

<h3 class="make">Código:</h3>
<pre><code class="language-c">
// gcc -std=c11 -Wall -Wextra -pedantic main.c -o abm
#include <stdio.h>
#include <string.h>

typedef struct {
    int id;
    char nombre[30];
    double sueldo; // Usar double en lugar de float para dinero, porque modifica si la cifra es mayor a 7 cifras
    int activo;
} Empleado;

/* ---PROTOTIPOS ---*/
void alta(void);
void listar(void);
void modificar(void);
void baja(void);

int main(void)
{
    int opcion;

    do {
        printf("\n--MENU ---\n");
        printf("1. Alta\n");
        printf("2. Listar\n");
        printf("3. Modificar\n");
        printf("4. Baja\n");
        printf("5. Salir\n");
        printf("Opcion: ");
        scanf("%d", &opcion);

        switch (opcion) {
            case 1:
                alta();
                break;
            case 2:
                listar();
                break;
            case 3:
                modificar();
                break;
            case 4:
                baja();
                break;
            case 5:
                printf("Saliendo...\n");
                break;
            default:
                printf("Opcion invalida\n");
        }
    } while (opcion != 5);

    return 0;
}

/* ---ALTA ---*/
void alta(void)
{
    FILE *fp = fopen("empleados.dat", "ab");
    if (fp == NULL) {
        printf("Error al abrir archivo\n");
        return;
    }

    Empleado e;

    printf("ID: ");
    scanf("%d", &e.id);

    printf("Nombre: ");
    scanf("%29s", e.nombre);

    printf("Sueldo: ");
    scanf("%lf", &e.sueldo);

    e.activo = 1;

    fwrite(&e, sizeof(Empleado), 1, fp);
    fflush(fp); // Vacia buffer (normalmente no es necesario, solo es didactico, se usa fclose(fp))

    printf("Empleado agregado\n");
}

/* ---LISTAR ---*/
void listar(void)
{
    FILE *fp = fopen("empleados.dat", "rb");
    if (fp == NULL) 
    {
        printf("No hay archivo\n");
        return;
    }

    /* DEMO SEEK_END + ftell */
    fseek(fp, 0, SEEK_END); // Va al final del archivo
    long tam = ftell(fp); // Dimension del archivo en bytes
    printf("Dimension del archivo: %ld bytes\n", tam);
    
    rewind(fp); // Vuelve al inicio del archivo (equivale a fseek(fp, 0, SEEK_SET))
    
    Empleado e;
    
    printf("\n --LISTADO ---\n");
    
    while (fread(&e, sizeof(Empleado), 1, fp) == 1)
    {
        if (e.activo) {
            printf("ID: %d | Nombre: %s | Sueldo: %.2f\n", e.id, e.nombre, e.sueldo);
        }
    }

    long pos = ftell(fp); // Posicion actual
    printf("Posicion actual en bytes: %ld\n", pos); 

    fclose(fp);

}

/* ---MODIFICAR ---*/
void modificar(void)
{
    FILE *fp = fopen("empleados.dat", "rb+");
    if (fp == NULL)
    {
        printf("No hay archivo\n");
        return;
    }

    int id;
    Empleado e;

    printf("ID a modificar: ");
    scanf("%d", &id);

    while (fread(&e, sizeof(Empleado), 1, fp) == 1)
    {
        if (e.id == id && e.activo)
        {
            printf("Nuevo sueldo: ");
            scanf("%lf", &e.sueldo);

            fseek(fp, -(long)sizeof(Empleado), SEEK_CUR);
            fwrite(&e, sizeof(Empleado), 1, fp);
            fclose(fp);

            printf("Empleado modificado\n");
            return;
        }
    }

    fclose(fp);
    printf("Empleado no encontrado\n");
}

/* ---BAJA LOGICA ---*/
void baja(void)
{
    FILE *fp = fopen("empleados.dat", "rb+");
    if (fp == NULL)
    {
        printf("No hay archivo\n");
        return;
    }

    int id;
    Empleado e;

    printf("ID a dar de baja: ");
    scanf("%d", &id);

    while (fread(&e, sizeof(Empleado), 1, fp) == 1)
    {
        if(e.id == id && e.activo)
        {
            e.activo = 0;

            fseek(fp, -(long)sizeof(Empleado), SEEK_CUR);
            fwrite(&e, sizeof(Empleado), 1, fp);
            fclose(fp);

            printf("Empleado dado de baja\n");
            return;
        }
    }

    fclose(fp);
    printf("Empleado no encontrado\n");
}
</code></pre>
</div>
</main>

<footer class="footer-nav">
  <div class="container">
  <a href="../teoria/file.html" class="btn">Anterior</a>
  <a href="../teoria/heap.html" class="btn">Siguiente</a>
  </div>
</footer>

<script src="../js/prism.js"></script>
<script src="../js/script.js"></script>

</body>

</html>

