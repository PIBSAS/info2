<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <link rel="icon" type="image/png" href="../img/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../img/favicon32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../img/favicon16.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TEMA 5</title>
  <meta name="author" content="Luciano Rabassa"/>
  <meta name="created" content="2026-02-02T10:27:00"/>
  <meta name="AppVersion" content="15.0000"/>
  <meta name="Company" content="Luciano's tech"/>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/prism.css">
  
</head>
<body>

<header class="site-header">
  <p class="materia">Informática II</p>
</header>

<main>
<div class="container">
<h1>Operadores a nivel de bit - Bitwise operators</h1>

<h2>¿Qué son?:</h2>
<p>
    Son operadores que no trabajan con valores "numéricos" 
        en el sentido aritmético, sino bit por bit sobre la
        representación binaria de un dato entero.
</p>

<h2>Se aplican sobre:</h2>
<ul>
    <li>char</li>
    <li>short</li>
    <li>int</li>
    <li>long</li>
    <li>Sus versiones unsigned</li>
</ul>
<div class="nota">
    <p><strong>NO APLICA a float, double, struct, etc.</strong></p>
</div>

<h2>Representación binaria:</h2>
<p>Supongamos un <strong><code>unsigned char</code></strong>(8 bits):</p>
<ul>
    <li><strong>Valor decimal:</strong> <code>13</code></li>
    <li><strong>Binario:</strong> <code>0000 1101</code></li>
</ul>
<p>Cada operador va a actuar bit a bit, comparando o modificando esos <strong>0</strong> y <strong>1</strong>.</p>

<h2>Operador AND bit a bit ( &amp; )</h2>

<p><strong>No confundir</strong> con el AND lógico (&amp;&amp;)</p>

<h3>Sintaxis:</h3>

<pre><code class="language-c">resultado = a & b;</code></pre>

<h3>Regla:</h3>
<p>Un bit vale 1 sólo si ambos bits son 1.</p>

<div class="tablecontainer">
    <table>
        <tr>
            <th>a</th>
            <th>b</th>
            <th>a &amp; b</th>
        </tr>
        <tr>
            <td>0</td>
            <td>0</td>
            <td>0</td>
        </tr>
        <tr>
            <td>0</td>
            <td>1</td>
            <td>0</td>
        </tr>
        <tr>
            <td>1</td>
            <td>0</td>
            <td>0</td>
        </tr>
        <tr>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
    </table>
</div>

<h3>Ejemplo:</h3>

<pre><code class="language-c">
unsigned char a = 12; // 0000 1100
unsigned char b = 10; // 0000 1010
unsigned char c = a & b; // 0000 1000 -> 8
</code></pre>

<h3>¿Para qué se usa?:</h3>
<ul>
    <li>Enmascarar bits.</li>
    <li>Ver si un bit específico está activo.</li>
</ul>
<h3>Ejemplo típico:</h3>
<pre><code class="language-c">
if (estado & 0x01) {
// el bit 0 esta en 1
}  
</code></pre>


<h2>Operador OR bit a bit (|)</h2>

<p><strong>No confundir</strong> con el OR lógico (||)</p>

<h3>Sintaxis:</h3>
<pre><code class="language-c">resultado = a | b;</code></pre>

<h3>Regla:</h3>
<p>Un bit vale 1 solo si al menos uno es 1.</p>

<div class="tablecontainer">
    <table>
        <tr>
            <th>a</th>
            <th>b</th>
            <th>a | b</th>
        </tr>
        <tr>
            <td>0</td>
            <td>0</td>
            <td>0</td>
        </tr>
        <tr>
            <td>0</td>
            <td>1</td>
            <td>1</td>
        </tr>
        <tr>
            <td>1</td>
            <td>0</td>
            <td>1</td>
        </tr>
        <tr>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
    </table>
</div>

<h3>Ejemplo:</h3>

<pre><code class="language-c">
unsigned char a = 12; // 0000 1100
unsigned char b = 10; // 0000 1010
unsigned char c = a | b; // 0000 1110 -> 24
</code></pre>

<h3>¿Para qué se usa?:</h3>
<ul>
    <li>Prender bits (Setear flags).</li>
</ul>

<h3>Ejemplo típico:</h3>

<pre><code class="language-c">
estado = estado | 0x04; // pone en 1 el bit 2
</code></pre>


<h2>Operador XOR bit a bit (^)</h2>

<p>Este es el más "raro" al principio.</p>

<h3>Sintaxis:</h3>
<pre><code class="language-c">resultado = a ^ b;</code></pre>

<h3>Regla:</h3>
<p>Un bit vale 1 solo si son distintos.</p>

<div class="tablecontainer">
    <table>
        <tr>
            <th>a</th>
            <th>b</th>
            <th>a ^ b</th>
        </tr>
        <tr>
            <td>0</td>
            <td>0</td>
            <td>0</td>
        </tr>
        <tr>
            <td>0</td>
            <td>1</td>
            <td>1</td>
        </tr>
        <tr>
            <td>1</td>
            <td>0</td>
            <td>1</td>
        </tr>
        <tr>
            <td>1</td>
            <td>1</td>
            <td>0</td>
        </tr>
    </table>
</div>

<h3>Ejemplo:</h3>

<pre><code class="language-c">
unsigned char a = 12; // 0000 1100
unsigned char b = 10; // 0000 1010
unsigned char c = a ^ b; // 0000 0110 -> 6
</code></pre>

<h3>¿Para qué se usa?:</h3>
<ul>
    <li>Invertir bits específicos.</li>
    <li>Truco histórico, hacer swap sin variable auxiliar, hoy en día solo didáctico.</li>
</ul>
<div class="nota">
  <p>
    Hoy en día este método <strong>no se recomienda</strong>:
    es menos legible y los compiladores modernos optimizan mejor
    el swap tradicional con variable auxiliar.
  </p>
</div>

<h3>Ejemplo típico:</h3>

<pre><code class="language-c">
estado ^= 0x01; // invierte el bit 0
</code></pre>


<h3>Swap sin variable auxiliar:</h3>

<pre><code class="language-c">
a = a ^ b;
b = a ^ b;
a = a ^ b;
</code></pre>

<h2>Operador NOT o Complemento a uno (~)</h2>

<h3>Sintaxis:</h3>
<pre><code class="language-c">resultado = ~a;</code></pre>

<h3>Regla:</h3>
<p>Invierte todos los bits:</p>
<ul>
    <li><strong><code>0 => 1</code></strong></li>
    <li><strong><code>1 => 0</code></strong></li>
</ul>

<div class="tablecontainer">
    <table>

        <tr>
            <th>a</th>
            <th>~a</th>
        </tr>

        <tr>
            <td>0</td>
            <td>1</td>
        </tr>
        
        <tr>
            <td>1</td>
            <td>0</td>
        </tr>
    </table>
</div>

<h3>Ejemplo:</h3>

<pre><code class="language-c">
unsigned char a = 5; // 0000 0101
unsigned char b = ~a; // 1111 1010 -> 250
</code></pre>
<div class="nota">
    <p><strong>IMPORTANTE:</strong>
    En tipos con signo, el resultado depende de la representación (en C usualmente Complemento a dos).
    Por eso para bitwise - bit a bit conviene usar <strong><code>unsigned</code></strong>.
    </p>
</div>

<h3>¿Para qué se usa?:</h3>
<ul>
    <li>Apagar bits con máscara.</li>
</ul>


<h3>Ejemplo típico:</h3>

<pre><code class="language-c">
estado &= ~0x04; // pone en 0 el bit 2  
</code></pre>


<h2>Desplazamiento a la izquierda - Shift left (&lt;&lt;)</h2>

<h3>Sintaxis:</h3>

<pre><code class="language-c">
resultado = a << n;
</code></pre>


<h3>¿Qué hace?:</h3>

<p>Desplaza los bits <strong><code>n</code></strong> posiciones a la izquierda, rellenando con ceros a la derecha.</p>


<h3>Ejemplo:</h3>

<pre><code class="language-c">
unsigned char a = 3; // 0000 0011
unsigned char b = a << 2; // 0000 1100 => 12
</code></pre>

<h3>Interpretación:</h3>

<p>Equivale para <strong><code>unsigned</code></strong> a multiplicar por 2<sup>n</sup>.</p>

<pre><code class="language-c">
a << 1 // Si a vale 1: 1 * 2^1 => 2
a << 2 // Si a vale 1: 1 * 2^2 => 4
</code></pre>
<div class="nota">
  <p>
    Esta equivalencia es válida siempre que no se pierdan bits.
    Si el desplazamiento provoca overflow, el comportamiento puede no coincidir
    con la multiplicación/división aritmética.
  </p>
</div>

<h2>Desplazamiento a la derecha - Shift right (&gt;&gt;)</h2>

<h3>Sintaxis:</h3>

<pre><code class="language-c">
resultado = a >> n;
</code></pre>


<h3>¿Qué hace?:</h3>
<p>Desplaza los bits <strong><code>n</code></strong> posiciones a la derecha, rellenando con ceros a la izquierda en tipos <strong><code>unsigned</code></strong>.</p>


<h3>Ejemplo:</h3>
<pre><code class="language-c">
unsigned char a = 8; // 0000 1000
unsigned char b = a >> 2; // 0000 0010 => 2
</code></pre>


<h3>Interpretación:</h3>

<p>Equivale para <strong><code>unsigned</code></strong> a dividir por 2<sup>n</sup>.</p>

<pre><code class="language-c">
a >> 1 // Si a vale 1: 1 / 2^1 => 0 (truncado)
a >> 2 // Si a vale 1: 1 / 2^2 => 0
</code></pre>
<div class="nota">
  <p>
    En C, los operadores de desplazamiento trabajan sobre <strong>enteros</strong>.
    Cualquier división descarta la parte fraccionaria (truncamiento).
  </p>
</div>

<h3>Shift right en tipos <strong><code>signed</code></strong>:</h3>

<p>Dependiente de la implementación.</p>

<ul>
    <li>Puede rellenar con ceros.</li>
    <li>O repetir el bit de signo (Shift aritmético). Por eso para bit a bit(bitwise) serio, se usa <strong><code>unsigned</code></strong>.</li>
</ul>


<h2>Bitwise - bit a bit vs Lógicos:</h2>

<div class="tablecontainer">
    <table>
        <tr>
            <th>Operador</th>
            <th>Tipo</th>
            <th>Resultado</th>
        </tr>
        <tr>
            <td>&amp;</td>
            <td>bitwise</td>
            <td>Opera bit a bit</td>
        </tr>
        <tr>
            <td>&amp;&amp;</td>
            <td>lógico</td>
            <td>0 o 1</td>
        </tr>
        <tr>
            <td>|</td>
            <td>bitwise</td>
            <td>Opera bit a bit</td>
        </tr>
        <tr>
            <td>||</td>
            <td>lógico</td>
            <td>0 o 1</td>
        </tr>
        <tr>
            <td>^</td>
            <td>bitwise</td>
            <td>Opera bit a bit</td>
        </tr>
        <tr>
            <td>&excl;</td>
            <td>lógico</td>
            <td>Negación lógica</td>
        </tr>
        <tr>
            <td>&tilde;</td>
            <td>bitwise</td>
            <td>Complemento a 1</td>
        </tr>
    </table>
</div>

<div class="nota">
  <p><strong>Resumen:</strong></p>
  <ul>
    <li>Los operadores bitwise trabajan a nivel de bits.</li>
    <li>Son ideales para flags, máscaras y control fino.</li>
    <li>Para evitar sorpresas, se recomienda usar <code>unsigned</code>.</li>
  </ul>
</div>

<h2 class="teoria">Teoría aplicada</h2>

<h3 class="make">Makefile:</h3>

<pre><code class="language-c">
CC = gcc
CFLAGS = -std=c11 -Wall -Wextra -pedantic

PROG = bitwise
OBJ = main.o

$(PROG): $(OBJ)
	$(CC) $(OBJ) -o $(PROG)

$(OBJ): main.c
	$(CC) $(CFLAGS) -c main.c

.PHONY: clean
clean:
	del $(OBJ) $(PROG).exe
</code></pre>

<h3 class="make">Código:</h3>

<pre><code class="language-c">
// gcc -std=c11 -Wall -Wextra -pedantic main.c -o bitwise

#include &lt;stdio.h&gt;

/* Funcion auxiliar para mostrar unsigned char en binario */
void binprint(unsigned char x)
{
    for (int i = 7; i >= 0; i--)
    {
        printf("%d", (x >> i) & 1);
        if (i == 4)
            printf(" ");
    }
}

int main(void)
{
    unsigned char a = 12; // 0000 1100
    unsigned char b = 10; // 0000 1010
    unsigned char r;

    printf("Valores iniciales:\n");
    printf("a = %3u = ", a); binprint(a); printf("\n");
    printf("b = %3u = ", b); binprint(b); printf("\n\n");

    /* ---- AND bitwise ---- */
    r = a & b;
    printf("AND bitwise (a & b):\n");
    printf("%3u = ", r); binprint(r); printf("\n\n");

    /* ---- OR bitwise ---- */
    r = a | b;
    printf("OR bitwise (a | b):\n");
    printf("%3u = ", r); binprint(r); printf("\n\n");

    /* ---- XOR bitwise ---- */
    r = a ^ b;
    printf("XOR bitwise (a ^ b):\n");
    printf("%3u = ", r); binprint(r); printf("\n\n");

    /* ---- NOT bitwise ---- */
    r = ~a;
    printf("NOT bitwise (~a):\n");
    printf("%3u = ", r); binprint(r); printf("\n\n");

    /* ---- SHIFT LEFT ---- */
    r = a << 2;
    printf("Shift left (a << 2):\n");
    printf("%3u = ", r); binprint(r); printf("\n\n");

    /* ---- SHIFT RIGHT ---- */
    r = a >> 2;
    printf("Shift right (a >> 2):\n");
    printf("%3u = ", r); binprint(r); printf("\n\n");

    return 0;
}
</code></pre>

</div>
</main>

<footer class="footer-nav">
  <div class="container">
  <a href="../teoria/bitfields.html" class="btn">Anterior</a>
  <a href="../teoria/file.html" class="btn">Siguiente</a>
  </div>
</footer>

<script src="../js/prism.js"></script>
<script src="../js/script.js"></script>

</body>
</html>