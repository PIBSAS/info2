<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TEMA 8</title>
  <meta name="author" content="Luciano Rabassa"/>
  <meta name="created" content="2026-02-01T12:25:00"/>
  <meta name="AppVersion" content="15.0000"/>
  <meta name="Company" content="Luciano's tech"/>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/prism.css">
</head>
<body>

<header class="site-header">
  <p class="materia">Informática II</p>
</header>

<main>
<div class="container">
<h1>Estructura de datos - Data structure</h1>

\[
\text{Estructura de datos} \left\{
\begin{array}{l}
  \text{Lectura destructiva} \quad \ \left\{
  \begin{array}{l}
    \text{Cola} \\
    \text{Pila}
  \end{array}
  \right. \\[6pt]

  \text{Lectura no destructiva} \left\{
  \begin{array}{l}
    \text{Lista} \\
    \text{Árbol}
  \end{array}
  \right.
\end{array}
\right.
\]

<h2>¿Qué es una estructura de datos?</h2>

<h3>Es una forma particular de:</h3>

<ul>
    <li>Organizar datos en memoria.</li>
    <li>Acceder a ellos</li>
    <li>Insertar y eliminar información.</li>
</ul>
<p>Con reglas bien definidas. NO es solo "guardar datos", sino como se comportan.</p>


<h2>Stack - Pila</h2>

<h3>¿Qué es?:</h3>

<p>Es una estructura de datos que sigue el principio:</p>
<ul>
    <li><strong><code>LIFO:</code></strong> Last In, First Out.</li>
    <li>Último en entrar, primero en salir.</li>
</ul>


<h4>Analogía:</h4>

<ul>
    <li>Una pila de platos.</li>
    <li>El último plato que ponemos arriba es el primero que sacamos.</li>
</ul>


<h3>Operaciones básicas del stack:</h3>

<ul>
    <li><strong><code>push:</code></strong> insertar un elemento.</li>
    <li><strong><code>pop:</code></strong> quitar un elemento.</li>
    <li><strong><code>peek/top:</code></strong> ver el elemento del tope.</li>
    <li><strong><code>isEmpty:</code></strong> verificar si está vacío.</li>
</ul>


<h3>Usos típicos del stack:</h3>

<ul>
    <li>Llamadas a funciones (<code>call stack</code>)</li>
    <li>Recursividad.</li>
    <li>Deshacer.</li>
    <li>Evaluación de expresiones.</li>
    <li>Backtracking.</li>
</ul>


<h2>Queue - Cola</h2>

<h3>¿Qué es?:</h3>

<p>Una cola es una estructura de datos que sigue el principio:</p>
<ul>
    <li><strong><code>FIFO:</code></strong> First In, First Out.</li>
    <li>Primero en entrar, primero en salir.</li>
</ul>
<h4>Analogía:</h4>
<ul>
    <li>Fila del banco.</li>
</ul>
<div class="nota">
    <p><strong>El primero que llega, es el primero que se atiende.</strong></p>
</div>


<h3>Operaciones básicas del queue:</h3>

<ul>
    <li><strong><code>enqueue:</code></strong> insertar al final.</li>
    <li><strong><code>dequeue:</code></strong> eliminar del frente.</li>
    <li><strong><code>front:</code></strong> ver el primer elemento.</li>
    <li><strong><code>isEmpty:</code></strong> verificar si está vacía.</li>
</ul>


<h3>Usos típicos del queue:</h3>

<ul>
    <li>Planificación de procesos.</li>
    <li>Impresoras.</li>
    <li>Buffers.</li>
    <li>Atención por orden de llegada.</li>
    <li>Sistemas operativos.</li>
</ul>

<h2>Stack vs Queue (Pila vs Cola)</h2>

<div class="tablecontainer">
    <table>
        <tr>
            <th>Característica</th>
            <th>Pila (Stack)</th>
            <th>Cola (Queue)</th>
        </tr>
        <tr>
            <td>Orden</td>
            <td>LIFO</td>
            <td>FIFO</td>
        </tr>
        <tr>
            <td>Inserción</td>
            <td>Tope</td>
            <td>Final</td>
        </tr>
        <tr>
            <td>Eliminación</td>
            <td>Tope</td>
            <td>Frente</td>
        </tr>
        <tr>
            <td>Analogía</td>
            <td>Platos</td>
            <td>Fila</td>
        </tr>
    </table>
</div>


<h2>Cola circular - Circular Queue</h2>

<h3>¿Qué es?:</h3>

<p>
    Es una mejora de la cola lineal que permite reutilizar
    el espacio liberado cuando se desencolan elementos.
</p>


<h3>Problema de la cola lineal:</h3>

<ul>
    <li>El índice de escritura (final) solo avanza.</li>
    <li>Aunque se liberen posiciones al frente, el espacio no puede reutilizarse.</li>
    <li><b>Puede darse la condición de:</b>
    <ul>
        <li>Cola vacía y cola llena lógicamente al mismo tiempo.</li>
    </ul>
    </li>
</ul>
        

<h3>Solución:</h3>

<ul>
    <li>Los índices de lectura (<b>frente</b>) y escritura (<b>final</b>) avanzan de forma circular.</li>
    <li>Cuando alcanzan el final del arreglo, vuelven al inicio (<b>salto circular</b>).</li>
</ul>


<h3>Características:</h3>

<ul>
    <li><strong><code>FIFO</code></strong></li>
    <li>Uso eficiente de la memoria.</li>
    <li><b>Requiere un criterio adicional para distinguir:</b>
    <ul>
        <li>Cola vacía.</li>
        <li>Cola llena.</li>
    </ul>
    </li>
</ul>
    

<h3>Formas de distinguir cola vacía y llena:</h3>

<ul>
    <li>Uso de un flag (<b>bandera</b>)</li>
    <li>Uso de un contador de elementos.</li>
    <li>Dejar una posición vacía (muy común).</li>
</ul>

<h3>En esta implementación:</h3>

<ul>
    <li>Se utiliza un contador de elementos.</li>
    <li>La cola está vacía cuando <strong><code>cantidad == 0;</code></strong></li>
    <li>La cola está llena cuando <strong><code>cantidad == MAX;</code></strong>.</li>
</ul>

<h2 class="teoria">Teoría aplicada</h2>

<h3 class="make">Makefile:</h3>
<pre><code class="language-c">
CC = gcc
CFLAGS = -std=c11 -Wall -Wextra -pedantic

PROG = data
OBJ = main.o

$(PROG): $(OBJ)
	$(CC) $(OBJ) -o $(PROG)

$(OBJ): main.c
	$(CC) $(CFLAGS) -c main.c

.PHONY: clean
clean:
	del $(OBJ) $(PROG).exe
</code></pre>

<h3 class="make">Código:</h3>
<pre><code class="language-c">
// gcc -std=c11 -Wall -Wextra -pedantic main.c -o data
#include <stdio.h>
#include <stdlib.h>

#define MAX 5

/* ..............................*/
/* ---- PILA (STACK) - LIFO ---- */
/* ..............................*/

typedef struct {
    int datos[MAX];
    int tope;
} Pila;

/* --- Inicializar Pila (Stack) --- */
void inicializarPila(Pila *p)
{
    p->tope = -1;
}

/* --- Verificar si la Pila (stack) esta vacia --- */
int pilaVacia(Pila *p)
{
    return p->tope == -1;
}

/* --- Verificar si la Pila (stack) esta llena --- */
int pilaLlena(Pila *p)
{
    return p->tope == MAX - 1;
}

/* --- PUSH - APILAR --- */
int push(Pila *p, int valor)
{
    if (pilaLlena(p))
    {
        return 0;
    }

    p->datos[++p->tope] = valor;

    return 1;
}

/* --- POP - DESAPILAR --- */
/*
    Devuelve:
        - 1: Si pudo extraer el elemnto.
        - 0: Si la pila esta vacia.
*/
int pop(Pila *p, int *valor)
{
    if (pilaVacia(p))
    {
        return 0;
    }

    *valor = p->datos[p->tope--];
    
    return 1;
}

/* ..............................*/
/* ---- COLA (QUEUE) - FIFO ---- */
/* ---- COLA LINEAL         ---- */ 
/* ..............................*/

typedef struct {
    int datos[MAX];
    int frente;
    int final;
} Cola;

/* --- Inicializar Cola (Queue) --- */
void inicializarCola(Cola *c)
{
    c->frente = 0;
    c->final = -1;
}

/* --- Verificar si la Cola (queue) esta vacia --- */
int colaVacia(Cola *c)
{
    return c->frente > c->final;
}

/* --- Verificar si la Cola (queue) esta llena --- */
int colaLlena(Cola *c)
{
    return c->final == MAX - 1;
}

/* --- ENQUEUE - ENCOLAR --- */
int enqueue(Cola *c, int valor)
{
    if (colaLlena(c))
    {
        return 0;
    }

    c->datos[++c->final] = valor;

    return 1;
}

/* --- DEQUEUE - DESENCOLAR --- */
/*
    Devuelve:
        - 1: Si pudo extraer el elemnto.
        - 0: Si la cola esta vacia.
*/
int dequeue(Cola *c, int *valor)
{
    if (colaVacia(c))
    {
        return 0;
    }

    *valor = c->datos[c->frente++];
    
    return 1;
}

/* ................................................*/
/* ---- COLA CIRCULAR (CIRCULAR QUEUE) - FIFO ---- */
/* ................................................*/

typedef struct {
    int datos[MAX];
    int frente;
    int final;
    int cantidad;
} ColaCircular;

/* --- Inicializar Cola Circular (Circular queue) ---*/
void inicializarColaCircular(ColaCircular *c)
{
    c->frente = 0;
    c->final = 0;
    c->cantidad = 0;
}

/* --- Verificar si la Cola Circular (circular queue) esta vacia --- */
int colaCircularVacia(ColaCircular *c)
{
    return c->cantidad == 0;
}

/* --- Verificar si la Cola Circular (circular queue) esta llena --- */
int colaCircularLlena(ColaCircular *c)
{
    return c->cantidad == MAX;
}

/* --- CIRCULAR ENQUEUE - ENCOLAR CIRCULAR --- */
int enqueueCircular(ColaCircular *c, int valor)
{
    if (colaCircularLlena(c))
    {
        return 0;
    }

    c->datos[c->final] = valor;
    c->final = (c->final + 1) % MAX; // % MAX es el "salto circular"
    c->cantidad++;

    return 1;
}

/* --- CIRCULAR DEQUEUE - DESENCOLAR CIRCULAR --- */
int dequeueCircular(ColaCircular *c, int *valor)
{
    if (colaCircularVacia(c))
    {
        return 0;
    }

    *valor = c->datos[c->frente];
    c->frente = (c->frente +1) % MAX; // % MAX es el "salto circular"
    c->cantidad--;

    return 1;
}

int main(void)
{
    Pila p;
    Cola c;
    int x;

    /* ---- PRUEBA DE PILA ---- */
    printf("PILA (STACK) - LIFO\n");
    inicializarPila(&p);

    push(&p, 10);
    push(&p, 20);
    push(&p, 30);

    while (pop(&p, &x)) // x recibe el dato y el tope baja
    {
        printf("Pop: %d\n", x);
    }

    /* ---- PRUEBA DE COLA LINEAL ---- */
    printf("\nCOLA (QUEUE) - FIFO\n");
    inicializarCola(&c);

    enqueue(&c, 10);
    enqueue(&c, 20);
    enqueue(&c, 30);

    while(dequeue(&c, &x)) // x recibe el dato y el frente avanza
    {
        printf("Dequeue: %d\n", x);
    }

    /* ---- PRUEBA DE COLA CIRCULAR ---- */
    printf("\nCOLA CIRCULAR (FIFO)\n");

    ColaCircular cc;
    inicializarColaCircular(&cc);

    enqueueCircular(&cc, 1);
    enqueueCircular(&cc, 2);
    enqueueCircular(&cc, 3);
    enqueueCircular(&cc, 4);
    enqueueCircular(&cc, 5);

    while (dequeueCircular(&cc, &x)) // x recibe el dato y el frente avanza
    {
        printf("Dequeue circular: %d\n", x);
    }

    return 0;
}
</code></pre>

</div>

</main>

<footer class="footer-nav">
  <div class="container">
  <a href="../teoria/heap.html" class="btn">Anterior</a>
  <a href="../teoria/list.html" class="btn">Siguiente</a>
  </div>
</footer>

<script src="../js/prism.js"></script>
<script src="../js/script.js"></script>

</body>
</html>

