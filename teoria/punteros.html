<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TEMA 1</title>
  <meta name="author" content="Luciano Rabassa"/>
  <meta name="created" content="2026-01-30T14:05:00"/>
  <meta name="AppVersion" content="15.0000"/>
  <meta name="Company" content="Luciano's tech"/>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/prism.css">
</head>
<body>

<header>
    <div class="container">
        <h1>Informática II</h1>
    </div>
</header>

<main>
  <div class="container">
<h1>Punteros</h1>

<p>Un puntero es una variable que almacena una direccion de memoria.
    A traves de este, se puede acceder o modificar el valor almacenado allí.</p>

<img class="img-center" src="../img/0001.png" alt="Ubicación en memoria">

<h2>Uso:</h2>
<ul>
  <li>Acceder y modificar variables desde funciones.</li>
  <li>Manejar arrays y strings.</li>
  <li>Usar memoria dinamica (malloc, free).</li>
  <li>Estructura de datos (listas-lists, pilas-stack, arboles-tree)</li>
  <li>Eficiencia y control de memoria.</li>
</ul>

<h2>Cómo se declara?:</h2>

<h3>Sintaxis:</h3>

<pre><code class="language-c">tipo_de_dato *nombre_del_puntero;</code></pre>

<b>Ejemplo:</b>
<pre><code class="language-c">int *pi;</code></pre>
<ul>
  <li>pi: es un puntero</li>
  <li>Apunta a una direccion donde hay un int</li>
  <li>El * indica que es un puntero, no una multiplicacion.</li>
  <li>Para que el puntero tenga sentido, debe apuntar a una variable existente:</li>
</ul>
<pre><code class="language-c">
int x = 10;
int *pi;
pi = &x; // Direccion de memoria de x, pi ahora guarda esa direccion.
</code></pre>

<h3>Acceder al valor usando un puntero (desreferenciar-object-of):</h3>
<ul>
  <li>Para acceder al contenido de la direccion a la que apunta el puntero se usa el operador * (Desreferencia-object-of):</li>
  </ul>
  <pre><code class="language-c">printf("%d", *pi) Imprime 10.</code></pre>
<ul>
  <li><b>pi:</b> direccion.</li>
  <li><b>*pi:</b> valor guardado en esa direccion.</li>
</ul>
    
<h3>Especificador de formato para direcciones:</h3>
<ul>
  <li><b>%p</b>: El estandard para este especificador de formato esta definido para imprimir punteros a <b>void</b>. Es por esto que el compilador nos advierte que con <b>&x</b> le estamos pasando <b>int *</b>, pero espera <b>void *</b>.</li>
  <li>Para solucionar esto se hace un cast: <b><code>(void *)&x;</code></b></li>
</ul>

<h1>Teoría aplicada:</h1>

<h2>Makefile:</h2>

<pre><code class="language-c">
CC = gcc
CFLAGS = -std=c11 -Wall -Wextra -pedantic

PROG = declaracion
OBJ = main.o

$(PROG): $(OBJ)
	$(CC) $(OBJ) -o $(PROG)

$(OBJ): main.c
	$(CC) $(OBJ) -c main.c

.PHONY: clean
clean:
	del $(OBJ) $(PROG).exe
</code></pre>


<h2>Código:</h2>

<pre><code class="language-c">
// gcc -std=c11 -Wall -Wextra -pedantic main.c -o declaracion

#include <stdio.h>

int main(void)
{
    int x = 5;
    int *pi = &x; //Declaracion y asignacion de memoria

    printf("Valor de x: %d\n", x);
    printf("Direccion de x: %p\n", &x); // El compilador espera que a la direccion se le haga un cast (void*)&x, pero lo deja pasar con solo un Warning, con esa solucion.
    printf("Direccion usando pi: %p\n", pi); // El compilador espera que a la direccion se le haga un cast (void*)&x, pero lo deja pasar con solo un Warning, con esa solucion.
    printf("Direccion de x: %p\n", (void *)&x); // Siguiendo el estandard
    printf("Direccion usando pi: %p\n", (void *)pi); //Siguiendo el estandard
    printf("Acceso al valor de x usando el puntero %d\n", *pi);
    
    return 0;
}
</code></pre>

<h2>Tamaño de los punteros</h2>
<p>Se utilizara el sinonimo dimensión.</p>

<p>TODOS los punteros tienen la misma dimension/tamanio (usemos el sinonimo dimension para tamanio, para claridad en los comentarios).
    Sin importar a que tipo apunten, ya que su dimension proviene del tipo de arquitectura en 32 bits es de 4 bytes, en 64 bits es de 8 bytes, se puede verificar con sizeof()</p>

<pre><code class="language-c">
sizeof(int *);
sizeof(float *);
sizeof(char *);
sizeof(double *);
</code></pre>

<h3><strong>No confundir con:</strong></h3>
<pre><code class="language-c">
sizeof(int);
</code></pre>

<h3>Ejemplo:</h3>

<pre><code class="language-c">
int *pi;
float *pf;
char *pc;
</code></pre>

<p><b>En una misma arquitectura, siempre sera cierto que:</b></p>
<pre><code class="language-c">
sizeof(pi) == sizeof(pf) == sizeof(pc)
</code></pre>

<p>Para impimir <b><code>sizeof(puntero a tipo de dato)</code></b> usamos el especificador de formato <b>%zu</b>:</p>
<pre><code class="language-c">
printf("%zu", sizeof(int *));
printf("%zu", sizeof(char *));
</code></pre>

<p>Van a imprimir lo mismo, que corresponde a la dimension del puntero en esa arquitectura.</p>

<h3>No confundir:</h3>

<pre><code class="language-c">int x;</code></pre>
<pre><code class="language-c">int *pi = &x;</code></pre>
<pre><code class="language-c">printf("%zu", sizeof(pi)); // Dimension del puntero pi. Mostrara 8 bytes. En arquitectura de 64 bits</code></pre>
<pre><code class="language-c">printf("%zu", sizeof(*pi)); // Dimension del tipo de dato al que apunta pi. Mostrara 4 bytes ya que sizeof(int) es 4 bytes</code></pre>


<h3>Relacion con arrays:</h3>

<pre><code class="language-c">
int a[10]; // sizeof(a) da 10 * sizeof(int) = 10 * 4 bytes = 40 bytes
int *p = a; // sizeof(p); da sizeof(int *) = 8 bytes
</code></pre>

<h1>Teoría aplicada:</h1>

<h2>Makefile:</h2>

<pre><code class="language-c">
CC = gcc
CFLAGS = -std=c11 -Wall -Wextra -pedantic

PROG = dimension
OBJ = main.o

$(PROG): $(OBJ)
	$(CC) $(OBJ) -o $(PROG)

$(OBJ): main.c
	$(CC) $(OBJ) -c main.c

.PHONY: clean
clean:
	del $(OBJ) $(PROG).exe
</code></pre>


<h2>Código:</h2>

<pre><code class="language-c">
// gcc -std=c11 -Wall -Wextra -pedantic main.c -o dimension
#include <stdio.h>

int main(void)
{
    int x;
    char c;
    double d;

    int *pi = &x;
    char *pc = &c;
    double *pd = &d;

    printf("int *:\t%zu bytes\n", sizeof(pi)); // Dimension de puntero
    printf("int:\t%zu bytes\n", sizeof(*pi));  // Dimension de tipo de dato

    printf("char *:\t%zu bytes\n", sizeof(pc));
    printf("char:\t%zu bytes\n", sizeof(*pc));

    printf("double *:\t%zu bytes\n", sizeof(pd));
    printf("double:\t%zu bytes\n", sizeof(*pd));

    return 0;
}
</code></pre>



</div>
</main>

<footer class="footer-nav">
  <div class="container">
  <a href="../index.html" class="btn">Anterior</a>
  <a href="../teoria/recursion.html" class="btn">Siguiente</a>
  </div>
</footer>

<script src="../js/prism.js"></script>
<script src="../js/script.js"></script>
</body>


</html>
