<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TEMA 1</title>
  <meta name="author" content="Luciano Rabassa"/>
  <meta name="created" content="2026-01-30T14:05:00"/>
  <meta name="AppVersion" content="15.0000"/>
  <meta name="Company" content="Luciano's tech"/>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/prism.css">
</head>
<body>

<header>
    <div class="container">
        <h1>Informática II</h1>
    </div>
</header>

<main>
  <div class="container">
<h1>Punteros</h1>

<p>Un puntero es una variable que almacena una direccion de memoria.
    A traves de este, se puede acceder o modificar el valor almacenado allí.</p>

<img class="img-center" src="../img/0001.png" alt="Ubicación en memoria">

<h2>Uso:</h2>
<ul>
  <li>Acceder y modificar variables desde funciones.</li>
  <li>Manejar arrays y strings.</li>
  <li>Usar memoria dinamica (malloc, free).</li>
  <li>Estructura de datos (listas-lists, pilas-stack, arboles-tree)</li>
  <li>Eficiencia y control de memoria.</li>
</ul>

<h2>Cómo se declara?:</h2>

<h2>Sintaxis:</h2>
<pre><code class="language-c">tipo_de_dato *nombre_del_puntero;</code></pre>

<h3>Ejemplo:</h3>
<pre><code class="language-c">int *pi;</code></pre>
<ul>
  <li>pi: es un puntero</li>
  <li>Apunta a una direccion donde hay un int</li>
  <li>El * indica que es un puntero, no una multiplicacion.</li>
  <li>Para que el puntero tenga sentido, debe apuntar a una variable existente:</li>
</ul>
<pre><code class="language-c">
int x = 10;
int *pi;
pi = &x; // Direccion de memoria de x, pi ahora guarda esa direccion.
</code></pre>

<h2>Acceder al valor usando un puntero (desreferenciar-object-of):</h2>
<ul>
  <li>Para acceder al contenido de la direccion a la que apunta el puntero se usa el operador * (Desreferencia-object-of):</li>
  </ul>
  <pre><code class="language-c">printf("%d", *pi) Imprime 10.</code></pre>
<ul>
  <li><b>pi:</b> direccion.</li>
  <li><b>*pi:</b> valor guardado en esa direccion.</li>
</ul>
    
<h2>Especificador de formato para direcciones:</h2>
<ul>
  <li><b>%p</b>: El estandard para este especificador de formato esta definido para imprimir punteros a <b>void</b>. Es por esto que el compilador nos advierte que con <b>&x</b> le estamos pasando <b>int *</b>, pero espera <b>void *</b>.</li>
  <li>Para solucionar esto se hace un cast: <b><code>(void *)&x;</code></b></li>
</ul>

<h1>Teoría aplicada:</h1>

<h2>Makefile:</h2>

<pre><code class="language-c">
CC = gcc
CFLAGS = -std=c11 -Wall -Wextra -pedantic

PROG = declaracion
OBJ = main.o

$(PROG): $(OBJ)
	$(CC) $(OBJ) -o $(PROG)

$(OBJ): main.c
	$(CC) $(OBJ) -c main.c

.PHONY: clean
clean:
	del $(OBJ) $(PROG).exe
</code></pre>


<h2>Código:</h2>

<pre><code class="language-c">
// gcc -std=c11 -Wall -Wextra -pedantic main.c -o declaracion

#include <stdio.h>

int main(void)
{
    int x = 5;
    int *pi = &x; //Declaracion y asignacion de memoria

    printf("Valor de x: %d\n", x);
    printf("Direccion de x: %p\n", &x); // El compilador espera que a la direccion se le haga un cast (void*)&x, pero lo deja pasar con solo un Warning, con esa solucion.
    printf("Direccion usando pi: %p\n", pi); // El compilador espera que a la direccion se le haga un cast (void*)&x, pero lo deja pasar con solo un Warning, con esa solucion.
    printf("Direccion de x: %p\n", (void *)&x); // Siguiendo el estandard
    printf("Direccion usando pi: %p\n", (void *)pi); //Siguiendo el estandard
    printf("Acceso al valor de x usando el puntero %d\n", *pi);
    
    return 0;
}
</code></pre>

<h1>Tamaño de los punteros</h1>
<p><strong>Se utilizara el sinonimo dimensión.</strong></p>

<p>TODOS los punteros tienen la misma dimension/tamanio (usemos el sinonimo dimension para tamanio, para claridad en los comentarios).
    Sin importar a que tipo apunten, ya que su dimension proviene del tipo de arquitectura en 32 bits es de 4 bytes, en 64 bits es de 8 bytes, se puede verificar con sizeof()</p>

<pre><code class="language-c">
sizeof(int *);
sizeof(float *);
sizeof(char *);
sizeof(double *);
</code></pre>

<h3><strong>No confundir con:</strong></h3>
<pre><code class="language-c">
sizeof(int);
</code></pre>

<h3>Ejemplo:</h3>

<pre><code class="language-c">
int *pi;
float *pf;
char *pc;
</code></pre>

<p><b>En una misma arquitectura, siempre sera cierto que:</b></p>
<pre><code class="language-c">
sizeof(pi) == sizeof(pf) == sizeof(pc)
</code></pre>

<p>Para impimir <b><code>sizeof(puntero a tipo de dato)</code></b> usamos el especificador de formato <b>%zu</b>:</p>
<pre><code class="language-c">
printf("%zu", sizeof(int *));
printf("%zu", sizeof(char *));
</code></pre>

<p>Van a imprimir lo mismo, que corresponde a la dimension del puntero en esa arquitectura.</p>

<h3>No confundir:</h3>

<pre><code class="language-c">int x;</code></pre>
<pre><code class="language-c">int *pi = &x;</code></pre>
<pre><code class="language-c">printf("%zu", sizeof(pi)); // Dimension del puntero pi. Mostrara 8 bytes. En arquitectura de 64 bits</code></pre>
<pre><code class="language-c">printf("%zu", sizeof(*pi)); // Dimension del tipo de dato al que apunta pi. Mostrara 4 bytes ya que sizeof(int) es 4 bytes</code></pre>


<h3>Relacion con arrays:</h3>

<pre><code class="language-c">
int a[10]; // sizeof(a) da 10 * sizeof(int) = 10 * 4 bytes = 40 bytes
int *p = a; // sizeof(p); da sizeof(int *) = 8 bytes
</code></pre>

<h1>Teoría aplicada:</h1>

<h2>Makefile:</h2>

<pre><code class="language-c">
CC = gcc
CFLAGS = -std=c11 -Wall -Wextra -pedantic

PROG = dimension
OBJ = main.o

$(PROG): $(OBJ)
	$(CC) $(OBJ) -o $(PROG)

$(OBJ): main.c
	$(CC) $(OBJ) -c main.c

.PHONY: clean
clean:
	del $(OBJ) $(PROG).exe
</code></pre>


<h2>Código:</h2>

<pre><code class="language-c">
// gcc -std=c11 -Wall -Wextra -pedantic main.c -o dimension
#include <stdio.h>

int main(void)
{
    int x;
    char c;
    double d;

    int *pi = &x;
    char *pc = &c;
    double *pd = &d;

    printf("int *:\t%zu bytes\n", sizeof(pi)); // Dimension de puntero
    printf("int:\t%zu bytes\n", sizeof(*pi));  // Dimension de tipo de dato

    printf("char *:\t%zu bytes\n", sizeof(pc));
    printf("char:\t%zu bytes\n", sizeof(*pc));

    printf("double *:\t%zu bytes\n", sizeof(pd));
    printf("double:\t%zu bytes\n", sizeof(*pd));

    return 0;
}
</code></pre>

<h1>Operadores de punteros</h1>

<h1>Operador & (Direccionamiento:address-of)</h1>

<h2>¿Qué hace?:</h2>
<p>Obtiene la direccion de memoria de una variable</p>
<pre><code class="language-c">
int x;
int *pi = &x;
</code></pre>
<ul>
  <li><b><code>x:</code></b> valor</li>
  <li><b><code>&x:</code></b> x</li>
  <li><b><code>int *:</code></b> tipo de dato de <b><code>&x</code></b></li>
</ul>

<h2>Se usa para:</h2>
<ul>
  <li>Inicializar punteros.</li>
  <li>Pasar variables a funciones.</li>
  <li>scanf.</li>
</ul>

<h1>Operador * (Desreferenciacion:Indireccion:object-of)</h1>

<h2>¿Qué hace?:</h2>

<p>Accede al valor almacenado en la direccion a la que apunta el puntero.</p>
<pre><code class="language-c">
int x = 10;
int *pi = &x;
printf("%d", *pi); Muestra 10
</code></pre>
<ul>
  <li><b><code>pi:</code></b> direccion de <b><code>x</code></b>.</li>
  <li><b><code>*pi:</code></b> valor almacenado en esa direccion</li>
</ul>
<p><strong>Usar <code>*</code> sobre un puntero no inicializado da un comportamiento indefinido-Undefined Behaviour (UB)</strong></p>

<h1>Teoría aplicada</h1>

<h2>Makefile:</h2>
<pre><code class="language-c">
CC = gcc
CFLAGS = -std=c11 -Wall -Wextra -pedantic

PROG = operadores
OBJ = main.o

$(PROG): $(OBJ)
	$(CC) $(OBJ) -o $(PROG)

$(OBJ): main.c
	$(CC) $(CFLAGS) -c main.c

.PHONY: clean
clean
	del $(OBJ) $(PROG).exe
</code></pre>

<h2>Código:</h2>
<pre><code class="language-c">
// gcc -std=c11 -Wall -Wextra -pedantic main.c -o operadores
#include <stdio.h>
int main(void)
{
    int x = 10;
    int y = 20;

    /*
        Operador & address-of
    */
    int *p1 = &x;
    int *p2 = &y;

    printf("Valores iniciales:\n");
    printf("x = %d, y = %d\n", x, y);

    /*
        Operador * Desrefenciacion, object-of
    */
    printf("\nAcceso mediante punteros a los valores almacenados en la direccion apuntada:\n");
    printf("*p1 = %d\n", *p1);
    printf("*p2 = %d\n", *p2);

    return 0;
}
</code></pre>

<h1>Operaciones que admiten los punteros</h1>

<h1>Operador = (Asignacion entre punteros)</h1>

<h2>¿Qué hace?:</h2>
<p>Copia la direccion de memoria, no el valor almacenado en esa direccion a la que apunta.</p>
<pre><code class="language-c">
int *p1, *p2;
p1 = &x; // Inicializa el puntero almacenando la direccion en memoria de x

/*Se asigna la direccion del puntero p1 en el puntero p2,
ambos apuntan a la misma direccion que almacena el tipo de dato,
de este modo p1 y p2 apuntan a la misma direccion*/
p2 = p1;
</code></pre>
    
<h1>Operadores de comparacion (==, !=, &lt;, &gt;, &leq;, &geq;)</h1>

<h2>¿Qué hace?:</h2>
<ul>
  <li>Comparan direcciones, NO valores.</li>
  <li><b><code>if(pi == p2)</code></b> Si apuntan al mismo lugar se cumple el bucle</li>
</ul>

<h3>Para comparar valores:</h3>
<ul>
  <li><b><code>if(*p1 == *p2)</code></b> Si almacenan el mismo valor en su direccion de memoria se cumple el bucle</li>
</ul>

<h1>Teoría aplicada</h1>

<h2>Makefile:</h2>
<pre><code class="language-c">
CC = gcc
CFLAGS = -std=c11 -Wall -Werror -pedantic

PROG = operaciones
OBJ = main.o

$(PROG):$(OBJ)
	$(CC) $(OBJ) -o $(PROG)

$(OBJ): main.c
	$(CC) $(CFLAGS) -c main.c

.PHONY: clean
clean
	del $(OBJ) $(PROG).exe
</code></pre>

<h2>Código:</h2>
<pre><code class="language-c">
  // gcc -std=c11 -Wall -Wextra -pedantic main.c -o operaciones
#include <stdio.h>

int main(void)
{
    int x = 10;
    int y = 20;

    int *p1 = &x;
    int *p2 = &y;

    /*
        Operador = Asignacion entre punteros
    */
    p2 = p1; // Ambos apuntan a la misma direccion, la de x

    printf("\n Despues de p2 = p1 los valores a los que acceden ambos punteros es:\n");
    printf("*p1 = %d\n", *p1);
    printf("*p2 = %d\n", *p2);

    /*
        Modificacion del valor almacenado en la direccion a traves del puntero
    */
    *p1 = 50;

    printf("\nDespues de modificar *p1 el valor de x almacenado en la direccion a la que apunta es:\n");
    printf("x = %d\n", x);
    printf("*p2 = %d (p2 apunta a x)\n", *p2);

    /*
        Operadores de comparacion
    */
    if (p1 == p2)
    {
        printf("\np1 y p2 apuntan a la misma direccion\n");
    }

    return 0;
}
</code></pre>

<h1>Aritmetica de punteros (+, -, ++, --)</h1>

<h2>¿Qué hace?:</h2>
<ul>
  <li>NO trabaja en bytes, trabaja en elementos del tipo apuntado.</li>
  <li>Un puntero "sabe" a que tipo apunta.</li>
</ul>

<h2>Operaciones permitidas:</h2>
<ul>
  <li><b><code>+:</code></b> p + n Donde <b>n</b> es un numero</li>
  <li><b><code>-:</code></b> p - n</li>
  <li><b><code>++:</code></b> p++</li>
  <li><b><code>--:</code></b> p--</li>
  <li><b><code>p1 - p2:</code></b> Solo si apuntan al mismo array</li>
</ul>

<h2>Operaciones que NO TIENEN SENTIDO con punteros:</h2>
<ul>
  <li><b><code>p + p</code></b></li>
  <li><b><code>*:</code></b> Multiplicación  <b><code>p * n</code></b> Causa error</li>
  <li><b><code>/:</code></b> División <b><code>p / n</code></b> Causa error</li>
  <li><b><code>%:</code></b> Módulo <b><code>p % n</code></b> Causa error</li>
  <li>Operaciones con <b><code>float</code></b>.</li>
  <li>Desplazamientos (&lt;&lt;, &gt;&gt;)</li>
  <li>Operaciones lógicas (&amp;&amp;, ||)</li>
</ul>

<h2>Regla fundamental:</h2>

<h3>Si:</h3>
<pre><code class="language-c">T *p;</code></pre>

<h3>Entonces:</h3>
<ul>
  <li><b><code>p + 1</code></b> &rArr; avanza <b><code>sizeof(T)</code></b> bytes. NO SUMA 1 byte. NO SUMA direcciones "a ojo".</li>
  <li>Suma 1 elemento del <b><code>tipo T</code></b>.</li>
</ul>

<h3>Ejemplo con array:</h3>
<pre><code class="language-c">
int a[5] = {10, 20, 30, 40, 50}; // vector de 5 elementos 0-4 de tipo entero llamado a
int *p = a; // Equivale a &a[0] es decir le esta asignando la direccion el primer elemnto del array declarado
p = p + 1;
/* Avanza sizeof(int) bytes,
apunta al siguiente elemento (a[1] cuyo valor en esa direccion es 20).
No suma bytes, suma elementos del tipo de dato.*/
</code></pre>

<ul>
  <li>Si <b><code>sizeof(int) == 4</code></b> cada <b><code>+1</code></b>, mueve <b><code>4 bytes</code></b>, pero eso es un detalle de implementación.</li>
  <li>Un puntero solo puede apuntar a elementos validos del array. Un elemento despues del ultimo (<b>ome-past-the-end</b>) como puntero pero no se puede desreferenciar</li>
  <li>Un puntero NO puede desreferenciar fuera del array. Apuntar antes del primer elemento (<b><code>a[-1]</code></b>)</li>
</ul>

<h3>Valido:</h3>
<pre><code class="language-c">int *p = a + 5; // Apunta "uno despues" de a[4]</code></pre>

<h3>Invalido:</h3>
<pre><code class="language-c">
*p = *(a + 5); // Comportamiento indefinido(UB)
p = a - 1; // Comportamiento indefinido(UB)
</code></pre>
    
<ul>
  <li>Especificador de formato <b><code>%td</code></b></li>
  <li>Especificador de formato para imprimir valores del tipo <b><code>ptrdiff_t</code></b> es <b><code>%td</code></b></li>
</ul>

<h2>¿Qué es ptrdiff_t?:</h2>
<h3>Cuando restamos dos punteros del mismo array:</h3>
<pre><code class="language-c">p - a; // No devuelve int, ni size_t, devuelve ptrdiff_t</code></pre>

<h3>¿Qué representa?:</h3>
<ul>
  <li>La cantidad de elementos entre ambos punteros</li>
  <li>Puede ser positivo o negativo.</li>
</ul>
<p><strong>Se debe incluir para seguir el estandar, la libreria <b><code>stddef.h</code></b></strong></p>

<h1>Teoría aplicada</h1>

<h2>Makefile:</h2>
<pre><code class="language-c">
CC = gcc
CFLAGS = -std=c11 -Wall -Wextra -pedantic

PROG = aritmetica
OBJ = main.o

$(PROG): $(OBJ)
	$(CC) $(OBJ) -o $(PROG)

$(OBJ): main.c
	$(CC) $(CFLAGS) -c main.c

.PHONY: clean
clean
	del $(OBJ) $(PROG).exe
</code></pre>

<h2>Código:</h2>
<pre><code class="language-c">
#include <stdio.h>
#include <stddef.h> //Puede omitirse porque no declaramos nada del tipo ptrdiff_t pero el estandar lo recomienda

int main(void)
{
    int a[5] = {10, 20, 30, 40, 50};
    int *p = a; // Declaracion y asignacion de la direccion del primer elemento del array, es decir apunta a a[0].

    printf("p apunta a a[0] cuyo valor almacenado en esa direccion es: %d\n", *p);

    p = p + 1;
    printf("p + 1 apunta a a[1], cuyo valor almacenado en esa direccion es: %d\n", *p);

    p++; //sumamos 1 elemento, llevandonos de a[1] a a[2]
    printf("\np++ apunta a a[2], cuyo valor almacenado en la direccion es: %d\n", *p);

    p = p - 2;
    printf("\np - 2 vuelve a a[0], cuyo valor almacenado en la direccion es: %d\n", *p);

    /*
    One-past-the-end es valido como puntero
    pero NO se puede desreferenciar
    */
    p = a + 5;
    printf("\np apunta a one-past-the-end (a + 5)\n");
    printf("Direccion de p %p\n", (void *)p);
    /*
        Comparacion valida
    */
    if (p > a)
    {
        printf("p es mayor que a (apunta a una direccion mas alta)\n");
    }
    /*
        Diferencia entre punteros
    */
    printf("\nCantidad de elementos entre p y a: %td\n", p - a);
    

    return 0;
}
</code></pre>

<h1>Punteros y Vectores</h1>

<p>En C, un vector y un puntero NO son lo mismo, pero estan intimamente relacionados.</p>

<h2>¿Qué es un array?:</h2>

<p>Un array es un objeto que representa N objetos del mismo tipo, almacenados en memoria contigua, cuyo tipo incluye su tamaño.</p>

<pre><code class="language-c">int a[5] = {10, 20, 30, 40, 50};</code></pre> 
<ul>
  <li><b><code>a</code></b> no es una variable asignable.</li>
  <li><b><code>a</code></b> no es un puntero.</li>
  <li><b><code>a</code></b> representa un objeto de tipo "array de <b>N</b> elementos"</li>
</ul>

<h2>¿Qué pasa cuando usamos el nombre del array?:</h2>
<p>En la mayoria de las expresiones, un array se convierte implícitamente en un puntero al primer elemento:</p>
<pre><code class="language-c">a</code></pre>

<h3>Se convierte automaticamente en:</h3>
<ul>
  <li><b><code>&a[0]</code></b> Es decir:</li>
  <ul>
    <li><b>Tipo:</b> <b><code>int *</code></b></li>
    <li><b><code>Valor:</code></b> direccion del primer elemento.</li>
  </ul>
</ul>

<h3>Ejemplo:</h3>

<pre><code class="language-c">
int *p = a; // Es correcto, se declara el puntero a int p y se le asigna la direccion de memoria del primer elemento de a[0]
int *q = &a[0]; // Es correcto y exactamente lo mismo que en la linea anterior.
</code></pre>

<p>Pero esto no convierte a <b><code>a</code></b> en un puntero, solo significa que en esa expresion se usa su direccion inicial</p>
<h3>Excepciones donde NO decae(decay) en puntero.</h3>
<pre><code class="language-c">
sizeof(a)
&a
</code></pre>

<p>Inicializacion directa del array.</p>

<h3>Diferencia fundamental con el puntero:</h3>
<pre><code class="language-c">
int a[5];
sizeof(a) // Es 5 * sizeof(int) = 5 * 4 bytes = 20 bytes su dimension
a = p; //NO PERMITIDO
</code></pre>
<p><strong>No puede cambiar a  que direccion de memoria apunta</strong></p>

<h3>Puntero:</h3> 
<pre><code class="language-c">
int *p;
sizeof(p) // Dimension del puntero segun arquitectura
p = a; // PERMITIDO
</code></pre>
<p><strong>Puede apuntar a otra cosa.</strong></p>

<h2>Acceso a elementos:</h2>
<h3>Misma sintaxis, distinto significado.</h3>
<pre><code class="language-c">
a[2] // Acceso al elemento 2 del array a.
p[2] // Acceso al objeto que esta 2 elementos despues de la direccion que guarda el puntero p.
</code></pre>

<h3>Ambos significan:</h3>
<pre><code class="language-c">
*(a + 2)
*(p + 2)
</code></pre>
<p><strong><b><code>[]:</code></b> El operador <b>[]</b> es pura aritmetica de punteros.</strong></p>

<h2>Relacion formal entre punteros y arrays:</h2>
<h3>Por definicion del lenguaje:</h3>
<pre><code class="language-c">
a[i] == *(a + i)
p[i] == *(p + i)
</code></pre>

<h3>Esto explica porque funciona esto:</h3>
<pre><code class="language-c">
int *p = a;
printf("%d", p[3]); // Imprime 40
</code></pre>

<p><strong>&amp;a NO es lo mismo que <code>a</code></strong></p>

<p>Esto es clave y suele confundir.</p>
<ul>
  <li><b><code>&a</code></b> <b>tipo:</b> <b><code>int (*)[5]</code></b> Puntero al array completo</li>
  <li><b><code>a</code></b>  <b>tipo:</b> <b><code>int *</code></b> Puntero al primer <b>int</b></li>
</ul>

<h3>Direcciones iguales, tipos distintos. Ej:</h3>
<pre><code class="language-c">
int a[5];
int *p =a;
printf("a\n", (void *)a);
printf("&a\n", (void *)&a); Direccion del array completo
printf("p\n", (void *)p);
</code></pre>
<p><strong>Las direcciones se ven iguales, los tipos NO, el compilador las trata distinto</strong></p>
   
<p>
  Un array no es un puntero, pero en la mayoría de las expresiones se convierte implícitamente en un puntero al primer elemento.
  El operador <b><code>[]</code></b> está definido en términos de aritmética de punteros,
  lo que explica por qué la misma sintaxis funciona tanto con <b>arrays</b> como con <b>punteros</b>.
</p>

<h1>Teoría aplicada</h1>

<h2>Makefile:</h2>
<pre><code class="language-c">
CC = gcc
CFLAGS = -std=c11 -Wall -Wextra -pedantic

PROG = vectores
OBJ = main.o

$(PROG): $(OBJ)
	$(CC) $(OBJ) -o $(PROG)

$(OBJ): main.c
	$(CC) $(CFLAGS) -c main.c
	
.PHONY: clean
clean:
	del $(OBJ) $(PROG).exe
</code></pre>

<h2>Código:</h2>
<pre><code class="language-c">
// gcc -std=c11 -Wall -Wextra -pedantic main.c -o vectores
#include <stdio.h>

 int main(void)
 {
   int a[5] = {10, 20, 30, 40, 50}; // Declaracion de un array de 5 elementos del tipo int con dimension 20 bytes(5*sizeof(int))
   int *p = a; // Declaracion de puntero a int p y asignacion de la primer direccion de memoria del array a (a[0])

   printf("a[2] = %d\n", a[2]);
   printf("p[2] = %d\n", p[2]);

   printf("*(a + 2) = %d\n", *(a + 2));
   printf("*(p + 2) = %d\n", *(p + 2));

   printf("\nsizeof(a) = %zu\n", sizeof(a));
   printf("\nsizeof(p) = %zu\n", sizeof(p));

   // Direccion de a cast a (void *)a. Ya que a (en esta expresion) decae a int *. &a es tipo: int (*)[5] array de 5 int(20bytes-array completo). p es tipo int *
   printf("\na\t = %p\n", (void *)a); // Direccion a traves de a
   printf("\n&a\t = %p\n", (void *)&a); // Direccion de a
   printf("\np\t = %p\n", (void *)p); // Direccion del puntero p
   
   return 0;
 }
</code></pre>

<h1>Pasaje de parametros por referencia</h1>

<p>
  En C NO existe el pasaje por referencia como concepto del lenguaje.
  C siempre pasa los argumentos por valor.
</p>

<h3>Lo que hacemos en C es:</h3>
<ul>
  <li>Pasar la direccion de un objeto.</li>
  <li>Y operar sobre ese objeto a traves de un puntero.</li>
</ul>
    
<h3>Ejemplo clásico:</h3>
<p>Porque NO funciona el "pasaje por valor"</p>

<pre><code class="language-c">
void cambiar(int x)
{
  x = 100;
}
int main(void)
{
  int a = 10;
  cambiar(a);
  printf("%d\n", a); // Imprime 10
  return 0;
}
</code></pre>

<h3>Que sucede aca?</h3>
<ul>
  <li><b><code>a</code></b> vale 10.</li>
  <li>Se copia su valor en <b><code>x</code></b></li>
  <li>Se modifica la copia.</li>
  <li><b><code>a</code></b> nunca cambia</li>
</ul>
<p><strong>Esto es pasaje por valor puro.</strong></p>

<h2>Solución:</h2>
<p>Pasar la direccion(Puntero)</p>
<pre><code class="language-c">
void cambiar(int *p)
{
  *p = 100;
}
int main(void)
{
  int a = 10;
  cambiar(&a);
  printf("%d\n", a); // Imprime 100
  return 0;
}
</code></pre>

<h2>¿Qué sucede aca?</h2>
<pre><code class="language-c">int a = 10; // Asignacion de variable</code></pre>
<pre><code class="language-c">cambiar(&a); // Direccion de memoria de a, se pasa esa dioreccion a la funcion</code></pre>
<pre><code class="language-c">void cambiar(int *p) // p recibe una copia de la direccion, p apunta a a</code></pre>

<h2>Desreferenciacion object-of a:</h2>
<pre><code class="language-c">*p = 100; // Se escribe en la memoria de a el valor 100, 'a' cambia.</code></pre>
<ul>
  <li>No se paso 'a' por referencia.</li>
  <li>Se paso la direccion de a por valor</li>
</ul>

<h2>Relacion con arrays:</h2>
<pre><code class="language-c">
void imprimir(int *p, int n)
{
  for (int i = 0; i < n; i++)
      printf("%d ", p[i]);
}
</code></pre>

<h3>Llamada:</h3>
<pre><code class="language-c">int a[5] = {1, 2, 3, 4, 5};</code></pre>
<pre><code class="language-c">imprimir(a, 5);</code></pre>
<ul>
  <li><b><code>a</code></b> decae a <b><code>&a[0]</code></b></li>
  <li>Se pasa un puntero</li>
  <li>La funcion accede al <b>array original</b>. Los arrays siempre se pasan <b>por referencia</b> en la practica</li>
  <li>Porque lo que se pasa es <b>su direccion inicial</b>.</li>
</ul>

<h1>Teoría aplicada</h1>

<h2>Makefile:</h2>
<pre><code class="language-c">
CC = gcc
CFLAGS = -std=c11 -Wall -Wextra -pedantic

PROG = parametros
OBJ = main.o

$(PROG): $(OBJ)
	$(CC) $(OBJ) -o $(PROG)

$(OBJ): main.c
	$(CC) $(CFLAGS) -c main.c

.PHONY: clean
clean:
	del $(OBJ) $(PROG).exe
</code></pre>

<h2>Código:</h2>
<pre><code class="language-c">
// gcc -std=c11 -Wall -Wextra -pedantic main.c -o parametros
#include <stdio.h>

/* ---------- Ejemplo 1: PASAJE POR VALOR (NO FUNCIONA) ---------- */

void cambiar_valor(int x)
{
    x = 100;   // Se modifica SOLO la copia
}

/* ---------- Ejemplo 2: PASAJE DE DIRECCION (FUNCIONA) ---------- */

void cambiar_direccion(int *p)
{
    *p = 100;  // Se modifica el objeto apuntado
}

/* ---------- Ejemplo 3: ARRAY COMO PARAMETRO ---------- */

void imprimir_array(int *p, int n)
{
    for (int i = 0; i < n; i++)
        printf("%d ", p[i]);
    printf("\n");
}

int main(void)
{
    /* ===== Ejemplo 1 ===== */
    int a = 10;

    printf("Antes de cambiar_valor: a = %d\n", a);
    cambiar_valor(a);
    printf("Despues de cambiar_valor: a = %d\n", a);

    /*
        a NO cambia porque:
        - Se paso el valor 10
        - Se modifico una copia
    */

    /* ===== Ejemplo 2 ===== */
    printf("\nAntes de cambiar_direccion: a = %d\n", a);
    cambiar_direccion(&a);
    printf("Despues de cambiar_direccion: a = %d\n", a);

    /*
        a cambia porque:
        - Se paso su direccion
        - Se escribio en su memoria
    */

    /* ===== Ejemplo 3 ===== */
    int v[5] = {1, 2, 3, 4, 5};

    printf("\nArray original:\n");
    imprimir_array(v, 5);

    /*
        v decae a &v[0]
        Se pasa la direccion del primer elemento
        La funcion accede al array original
    */

    return 0;
}
</code></pre>

</div>
</main>

<footer class="footer-nav">
  <div class="container">
  <a href="../index.html" class="btn">Anterior</a>
  <a href="../teoria/recursion.html" class="btn">Siguiente</a>
  </div>
</footer>

<script src="../js/prism.js"></script>
<script src="../js/script.js"></script>
</body>


</html>
