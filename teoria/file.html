<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TEMA 6</title>
  <meta name="author" content="Luciano Rabassa"/>
  <meta name="created" content="2026-02-01T13:39:00"/>
  <meta name="AppVersion" content="15.0000"/>
  <meta name="Company" content="Luciano's tech"/>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/prism.css">
</head>

<body>

<header class="site-header">
  <p class="materia">Informática II</p>
</header>

<main>
<div class="container">

<h1>Archivos - FILE *</h1>
<h2>Parte 1</h2>
<h3 class="tema">Acceso secuencial</h3>


<h2>¿Qué es un archivo - file and stream?</h2>

<p>
    Una secuencia de bytes almacenada en algún dispositivo (disco, pendrive, etc)
    a la que se accede de forma secuencial o aleatoria mediante un flujo (stream).
</p>


<h2>FILE *:</h2>

<p>
    En C NUNCA trabajamos directamente con el archivo.
    Siempre trabajamos con un puntero a una estructura interna:
</p>

<pre><code class="language-c">FILE *fp;</code></pre>

<h3>Ese FILE:</h3>

<ul>
    <li>NO lo definimos nosotros.</li>
    <li>NO sabemos como es por dentro. (A menos que nos documentemos al respecto, viendo la librería estandar)</li>
    <li>Lo maneja la biblioteca estandar.</li>
    <li>Nosotros usamos el puntero.</li>
</ul>

<h2>Apertura de un archivo:</h2>

<pre><code class="language-c">fopen</code></pre>

<h3>Sintaxis:</h3>
<pre><code class="language-c">FILE *fopen(const char *nombre, const char *modo);</code></pre>

<h3>Ejemplo:</h3>
<pre><code class="language-c">FILE *fp = fopen("datos.txt", "r");</code></pre>

<h3>¿Qué hace?:</h3>
<ul>
    <li>Busca el archivo.</li>
    <li>Prepara buffers.</li>
    <li>Devuelve un FILE *</li>
</ul>
<div class="nota">
    <p><strong>Si falla devuelve <code>NULL</code>.</strong></p>
</div>


<h3>Regla:</h3>
<ul>
    <li>TODO <strong><code>fopen</code></strong> exitoso debe tener su <strong><code>fclose</code></strong>.</li>
</ul>

<h2>Cierre de un archivo:</h2>
<pre><code class="language-c">fclose</code></pre>

<h3>Sintaxis:</h3>
<pre><code class="language-c">int fclose(FILE *fp);</code></pre>

<h3>Es la funcion que:</h3>
<ul>
    <li>Cierra el archivo asociado al FILE *</li>
    <li>Vacia los buffers pendientes</li>
    <li>Libera recursos del sistema operativo</li>
</ul>
<div class="nota">
    <p><strong>Sin <code>fclose</code>, el archivo NO esta realmente terminado.</strong></p>
</div>


<h3>Que pasa internamente cuando usamos <code>fclose</code>?</h3>

<p>Aunque no lo vemos, pasan varias cosas:</p>

<ul>
    <li>Se vacian los buffers:
    <ul>
        <li>Lo escrito con fputc, fprintf, etc.</li>
        <li>Puede que todavia no este en el disco.</li>
    </ul>
    </li>
</ul>
<ul>
    <li>Se libera memoria:
    <ul>
        <li>Estructuras internas (FILE)</li>
        <li>Descriptores del sistema.</li>
    </ul>
    </li>
</ul>
<ul>
    <li>Se libera el archivo:
    <ul>
        <li>Otros programas pueden usarlo.</li>
        <li>Se asegura la integridad del archivo.</li>
    </ul>
    </li>
</ul>


<h2>¿Qué pasa si NO llamamos a fclose?</h2>

<p>Depende... y eso es lo peligroso.</p>

<h4>Posibles consecuencias:</h4>
<ul>
    <li>El archivo queda incompleto.</li>
    <li>Los últimos datos no se escriben.</li>
    <li>Fugas de recursos.</li>
    <li>En algunos sistemas:
        <ul>
            <li>El archivo puede quedar corrupto.</li>
            <li>O no aparecer.</li>
        </ul>
        </li>
    <li>En programas chicos "parece funcionar".</li>
    <li>En programas reales mata su funcionamiento.</li>
</ul>


<h3>Valor de retorno de fclose:</h3>

<pre><code class="language-c">int r = fclose(fp);</code></pre>

<ul>
    <li><strong><code>0 => OK</code></strong></li>
    <li><strong><code>EOF</code></strong> => Error al cerrar</li>
</ul>

<h3>Ejemplo:</h3>

<pre><code class="language-c">
if (fclose(fp) == EOF)
{
    printf("Error al cerrar el archivo\n");
}
</code></pre>

<h3>Regla:</h3>
<ul>
    <li>Cada <strong><code>fopen</code></strong> exitoso debe tener exactamente un <strong><code>fclose</code></strong>.</li>
</ul>


<h2>Modos de apertura:</h2>

<div class="tablecontainer">
    <table>
        <tr>
            <th>Modo</th>
            <th>Significado</th>
        </tr>
        <tr>
            <td>"r"</td>
            <td>Leer (debe existir)</td>
        </tr>
        <tr>
            <td>"w"</td>
            <td>Escribir (borra o crea)</td>
        </tr>
        <tr>
            <td>"a"</td>
            <td>Agregar al final</td>
        </tr>
        <tr>
            <td>"r+"</td>
            <td>Leer y escribir</td>
        </tr>
        <tr>
            <td>"w+"</td>
            <td>Leer y escribir (borra lo existente)</td>
        </tr>
        <tr>
            <td>"a+"</td>
            <td>Leer y escribir al final</td>
        </tr>
    </table>
</div>

<ul>
    <li><strong>"w":</strong> Borra el archivo si existe.</li>
    <li><strong>"r":</strong> Falla si no existe.</li>
</ul>


<h2>Escritura de un caracter:</h2>
<pre><code class="language-c">fputc</code></pre>

<h3>Sintaxis:</h3>
<pre><code class="language-c">int fputc(int c, FILE *fp);</code></pre>

<h3>¿Qué hace?:</h3>
<ul>
    <li>Escribe un solo caracter en el archivo.</li>
    <li>Avanza el puntero de archivo.</li>
    <li>Devuelve:
    <ul>
        <li>El caracter escrito (como <strong><code>unsigned char</code></strong>)</li>
        <li><strong><code>EOF</code></strong> si hay error.</li>
    </ul>
    </li>
</ul>

<h3>Ejemplo:</h3>

<pre><code class="language-c">
FILE *fp = fopen("salida.txt", "w");

if (fp == NULL)
    return 1;

fputc('H', fp);
fputc('o', fp);
fputc('l', fp);
fputc('a', fp);
fputc('\n', fp);

fclose(fp);
</code></pre>

<h3>Contenido del archivo:</h3>
<pre><code class="language-c">Hola</code></pre>

<div class="nota">
    <p><strong>IMPORTANTE:</strong>
    <strong><code>fputc</code></strong> NO escribe inmediatamente al disco.</p>
    <ul>
        <li>Va al buffer.</li>
        <li>Se garantiza la escritura real con:
        <ul>
            <li><strong><code>fclose</code></strong></li>
            <li><strong><code>fflush</code></strong></li>
        </ul>
        </li>
    </ul>
</div>


<h2>Lectura de un caracter:</h2>
<pre><code class="language-c">fgetc</code></pre>

<h3>Sintaxis:</h3>
<pre><code class="language-c">int fgetc(FILE *fp);</code></pre>

<h3>¿Qué hace?:</h3>
<ul>
    <li>Lee un caracter del archivo.</li>
    <li>Avanza el puntero.</li>
    <li><strong>Devuelve:</strong>
    <ul>
        <li>El caracter leido.</li>
        <li><strong><code>EOF</code></strong> si:
        <ul>
            <li>Llega al fin del archivo.</li>
            <li>Ocurre un error</li>
        </ul>
        </li>
    </ul>
    </li>
    <li><strong>Esto es clave:</strong>
    <ul>
        <li><code>EOF</code> no distingue un error de fin de archivo.</li>
    </ul>
    </li>
</ul>


<h3>Ejemplo:</h3>

<pre><code class="language-c">
int c;
FILE *fp = fopen("salida.txt", "r");

if (fp == NULL)
    return 1;

while ((c = fgetc(fp)) != EOF)
{
    putchar(c);
}

fclose(fp);
</code></pre>

<div class="nota">
    <p><strong>OBSERVACION:</strong></p>
    <ul>
        <li><strong><code>fgetc:</code></strong> Devuelve <strong><code>int</code></strong>.</li>
        <li><strong><code>EOF:</code></strong> NO es un <strong><code>char</code></strong>.</li>
        <li>Por eso la variable es <strong><code>int</code></strong>.</li>
    </ul>
</div>


<h2>Detección de fin de archivo:</h2>

<h3><strong><code>EOF:</code></strong></h3>

<p>No es un caracter.</p>
<ul>
    <li>Es un valor especial (normalmente <strong><code>-1</code></strong>)</li>
    <li>Forma correcta de utilizarlo:</li>
</ul>
<pre><code class="language-c">while ((c = fgetc(fp)) != EOF)</code></pre>

<p>Para distinguir <strong>Fin de archivo</strong> vs <strong>Error</strong> de lectura, utilizamos <strong><code>feof</code></strong> ¿Fin de archivo?.</p>


<h3>Sintaxis:</h3>
<pre><code class="language-c">int feof(FILE *fp);</code></pre>
<ul>
    <li>Devuelve distinto de <strong><code>0</code></strong> solo despues de intentar leer y fallar por <strong><code>EOF</code></strong>.</li>
    <li>NO se adelanta.</li>
</ul>


<h3>Forma incorrecta, error clásico:</h3>

<pre><code class="language-c">
while (!feof(fp)) // MAL
{
    c = fgetc(fp);
}
</code></pre>
<div class="nota">
    <p><strong><code>feof</code> se usa despues, no para controlar el loop.</strong></p>
</div>


<h2>ferror - ¿Error?:</h2>

<h3>Sintaxis:</h3>
<pre><code class="language-c">int ferror(FILE *fp);</code></pre>
<ul>
    <li>Devuelve <strong>distinto de 0</strong> si ocurrio un error de <strong>I/O</strong> (Input/Output)</li>
</ul>


<h3>Patrón correcto de lectura robusta:</h3>

<h3>Ejemplo:</h3>
<pre><code class="language-c">
int c;

while ((c = fgetc(fp)) != EOF)
{
  putchar(c);
}

if (feof(fp)) // Detecta fin
{
  printf("\nFin de archivo alcanzado\n");
}
else if (ferror(fp)) // Detecta error
{
  printf("\nError de lectura\n");
}
</code></pre>
<div class="nota">
    <p><strong>Este es el patrón canónico en C.</strong></p>
</div>

<h2>Escritura de un string:</h2>
<pre><code class="language-c">fputs</code></pre>

<h3>Sintaxis:</h3>
<pre><code class="language-c">int fputs(const char *str, FILE *fp);</code></pre>


<h3>¿Qué hace?</h3>
<ul>
    <li>Escribe un string completo en el archivo.</li>
    <li>NO agrega <strong><code>\n</code></strong> automáticamente.</li>
    <li>Devuelve:
    <ul>
        <li>Valor <strong>no negativo</strong> si tuvo éxito.</li>
        <li><strong><code>EOF</code></strong> si hubo error.</li>
    </ul>
    </li>
</ul>


<h3>Ejemplo:</h3>

<pre><code class="language-c">
FILE *fp = fopen("texto.txt", "w");

if (fp == NULL)
  return 1;

fputs("Hola mundo", fp);
fputs("\n", fp);
fputs("Segunda linea", fp);

fclose(fp);
</code></pre>

<h3>Contenido del archivo:</h3>

<pre><code class="language-c">
Hola mundo
Segunda linea
</code></pre>


<h2>Diferencia clave con puts:</h2>

<div class="tablecontainer">
    <table>
        <tr>
            <th>Función</th>
            <th>Destino</th>
            <th>Agrega n</th>
        </tr>
        <tr>
            <td>puts</td>
            <td>stdout</td>
            <td>sí</td>
        </tr>
        <tr>
            <td>fputs</td>
            <td>archivo</td>
            <td>no</td>
        </tr>
    </table>
</div>


<h2>Lectura de un string:</h2>
<pre><code class="language-c">fgets</code></pre>

<h3>Sintaxis:</h3>
<pre><code class="language-c">char *fgets(char *str, int n, FILE *fp);</code></pre>

<h3>¿Qué hace?:</h3>
<ul>
    <li>Lee hasta <strong><code>n-1</code></strong> caracteres.</li>
    <li>Se detiene si encuentra:
        <ul>
            <li><strong><code>\n</code></strong></li>
            <li><strong><code>EOF</code></strong></li>
        </ul>
    </li>
    <li>Incluye el <strong><code>\n</code></strong> si lo lee.</li>
    <li>Siempre agrega <strong><code>'\0'</code></strong></li>
    <li>Devuelve:
        <ul>
            <li><strong><code>str</code></strong> si pudo leer algo.</li>
            <li><strong><code>NULL</code></strong> si no pudo (<strong><code>EOF</code></strong> o <strong>error</strong>)</li>
        </ul>
    </li>
</ul>


<h3>Ejemplo:</h3>

<pre><code class="language-c">
FILE *fp = fopen("texto.txt", "r");

if (fp == NULL)
    return 1;

char linea[100]; // 99 char + \0

while (fgets(linea, sizeof(linea), fp) != NULL)
{
    printf("%s", linea);
}
fclose(fp);
</code></pre>


<h3>Salida:</h3>

<pre><code class="language-c">
Hola mundo
Segunda linea
</code></pre>

<p><strong>IMPORTANTE:</strong></p>
<ul>
    <li>Lee como maximo <strong><code>n-1</code></strong>, si <strong><code>n = 100</code></strong>, lee hasta <strong><code>99 caracteres + \0</code></strong></li>
    <li>Evita desbordes (overflow)</li>
    <li>A diferencia de <strong><code>gets</code></strong> (Que esta prohibida)</li>
    <li>El <strong><code>\n</code></strong> queda adentro. Ejemplo:
        <ul>
            <li><strong><code>fgets(linea, 100, fp);</code></strong></li>
        </ul>
    </li>
</ul>

<p>Si el archivo tiene:</p>
<pre><code class="language-c">Hola</code></pre>

<p><strong>El buffer queda:</strong></p>
<pre><code class="language-c">"Hola\n\0"</code></pre>

<p><strong>Por eso muchas veces se ve:</strong></p>
<pre><code class="language-c">
linea[strcspn(linea, "\n")] = '\0';
NULL = no se leyo nada.
</code></pre>
<div class="nota">
    <p><strong>No significa solo <strong><code>EOF</code></strong>, puede ser <strong>error</strong> tambien.</strong></p>
</div>


<h3>Patron correcto:</h3>

<pre><code class="language-c">
if (fgets(linea, sizeof(linea), fp) == NULL)
{
    if (feof(fp))
        printf("Fin de archivo\n");
    else
        printf("Error\n");
}
</code></pre>


<h2>Comparación:</h2>

<div class="tablecontainer">
    <table>
        <tr>
            <th>Función</th>
            <th>Nivel(abstracción)</th>
            <th>Uso</th>
        </tr>
        <tr>
            <td>fgetc</td>
            <td>bajo(carácter)</td>
            <td>lectura simple</td>
        </tr>
        <tr>
            <td>fgets</td>
            <td>medio(línea completa)</td>
            <td>lectura segura</td>
        </tr>
        <tr>
            <td>fscanf</td>
            <td>alto(formateado)</td>
            <td>lectura con formato</td>
        </tr>
    </table>
</div>


   
<h2>Escritura con formato:</h2>

<pre><code class="language-c">fprintf</code></pre>

<h3>Sintaxis:</h3>
<pre><code class="language-c">int fprintf(FILE *fp, const char *formato, ...);</code></pre>

<h3>¿Qué hace?:</h3>
<ul>
    <li>Escribe texto formateado en un archivo.</li>
    <li>Devuelve:
        <ul>
            <li>Cantidad de caracteres escritos.</li>
            <li>Valor negativo si hay error.</li>
        </ul>
    </li>
</ul>


<h3>Ejemplo:</h3>

<pre><code class="language-c">
FILE *fp = fopen("datos.txt", "w");
if (fp == NULL)
  return 1;

int edad = 25;
float altura = 1.75;

fprintf(fp, "Edad: %d\n", edad);
fprintf(fp, "Altura: %.2f\n", altura);

fclose(fp);
</code></pre>


<h3>Contenido del archivo:</h3>

<pre><code class="language-c">
Edad: 25
Altura: 1.75
</code></pre>


<h2>Formatos validos:</h2>

<p>Los mismos que <strong><code>printf</code></strong>:</p>
<ul>
    <li>%d, %f, %s, %c.</li>
    <li>%lf, para double</li>
    <li>%u, %ld, etc.</li>
</ul>


<h2>Lectura con formato:</h2>
<pre><code class="language-c">fscanf</code></pre>

<h3>Sintaxis:</h3>
<pre><code class="language-c">int fscanf(FILE *fp, const char *formato, ...);</code></pre>

<h3>¿Qué hace?:</h3>
<p>Lee datos formateados desde un archivo.</p>
<p><strong>Devuelve:</strong></p>
<ul>
    <li>Cantidad de elementos leidos correctamente.</li>
    <li><strong><code>EOF</code></strong> si no pudo leer nada.</li>
</ul>


<h3>Ejemplo:</h3>

<p>Archivo <strong><code>persona.txt:</code></strong></p>
<pre><code class="language-c">25 1.75</code></pre>

<h3>Código:</h3>
<pre><code class="language-c">
FILE *fp = fopen("persona.txt", "r");
if (fp == NULL)
  return 1;

int edad;
float altura;

fscanf(fp, "%d %f", &edad, &altura);

printf("Edad=%d ALtura %.2f\n", edad, altura);

fclose(fp);
</code></pre>

<h3>Peligros reales de <strong><code>fscanf</code></strong>:</h3>

<p>No controla limites de strings</p>
<pre><code class="language-c">
char nombre[20];
fscanf(fp, "%s", nombre); // Peligro si el nombre es largo
</code></pre>


<h3>Mejor:</h3>
<pre><code class="language-c">fscanf(fp, "%19s", nombre);</code></pre>

<p>No detecta bien fin de archivo</p>

<p><strong>Error tipico:</strong></p>
<pre><code class="language-c">
while (!feof(fp))
{
  fscanf(fp, "%d", &x);
}
</code></pre>

<h3>Patron correcto con fscanf:</h3>
<pre><code class="language-c">
while (fscanf(fp, "%d", &x) == 1)
{
    printf("%d\n", x);
}
</code></pre>

<p><strong>O con multiples datos:</strong></p>
<pre><code class="language-c">
while (fscanf(fp, "%d %f", &a, &b) == 2)
{
    ...
}
</code></pre>
<div class="nota">
    <p><strong>El <strong><code>==</code></strong> cantidad de campos, es clave.</strong></p>
</div>


<h2>fscanf vs fgets + sscanf:</h2>

<div class="tablecontainer">
    <table>
        <tr>
            <th>Función</th>
            <th>Ventaja</th>
            <th>Problema</th>
        </tr>
        <tr>
            <td>fscanf</td>
            <td>directo</td>
            <td>frágil</td>
        </tr>
        <tr>
            <td>fgets</td>
            <td>segura</td>
            <td>hay que parsear</td>
        </tr>
    </table>
</div>

<p><strong>Por eso en código serio se suele hacer:</strong></p>

<pre><code class="language-c">
fgets(linea, sizeof(linea), fp);
sscanf(linea, "%d %f", &a, &b);
</code></pre>

<h3>fgets:</h3>
<ul>
    <li>Controla cuanto entra.</li>
    <li>Nunca se pasa del buffer.</li>
    <li>Sabe exactamente cuando fallo.</li>
</ul>

<h3>sscanf:</h3>
<ul>
    <li>Trabaja sobre memoria, no sobre archivo.</li>
    <li>No avanza el puntero del archivo.</li>
    <li>Permite validar mejor lo leido.</li>
</ul>


<h3>Ejemplo:</h3>

<pre><code class="language-c">
char linea[100];
int a;
float b;
while (fgets(linea, sizeof(linea), fp))
{
    if (sscanf(linea, "%d %f", &a, &b) == 2)
    {
        printf("a=%d b=%.2f\n", a, b);
    }
    else
    {
        printf("Linea mal formada\n");
    }
}
</code></pre>

<p>
    Esto no se puede hacer limpio con <strong><code>fscanf</code></strong>
    Pero la clásica suele ser usar <strong><code>fscanf</code></strong>
</p>


<h2 class="teoria">Teoría aplicada</h2>

<h3 class="make">Makefile:</h3>
<pre><code class="language-c">
CC = gcc
CFLAGS = -std=c11 -Wall -Wextra -pedantic

PROG = files
OBJ = main.o

$(PROG): $(OBJ)
	$(CC) $(OBJ) -o $(PROG)

$(OBJ): main.c
	$(CC) $(CFLAGS) -c main.c

.PHONY: clean
clean:
	del $(OBJ) $(PROG).exe *.txt
</code></pre>

<h3 class="make">Código:</h3>
<pre><code class="language-c">
// gcc -std=c11 -Wall -Wextra -pedantic main.c -o files
#include <stdio.h>

int main(void)
{
    /* ---- DECLARACION ---- */
    FILE *fp;

    /* ---- APERTURA Y ESCRITURA DE ARCHIVO fopen fputc ---- */
    fp = fopen("datos.txt", "w");

    if (fp == NULL)
    {
        printf("No se pudo abrir el archivo\n");
        return 1;
    }
    
     /* ---- ESCRITURA DE CARACTERES fputc ---- */
    fputc('H', fp);
    fputc('o', fp);
    fputc('l', fp);
    fputc('a', fp);
    fputc('\n', fp);

    /* ---- ESCRITURA DE STRING fputs ---- */
    fputs("Linea uno\n", fp);

    /* ---- ESCRITURA DE CON FORMATO fprintf ---- */
    fprintf(fp, "Edad: %d Altura: %.2f\n", 25, 1.75);
    
    fclose(fp); // SIEMPRE cerrar

    /* ---- LECTURA CARACTER A CARACTER ---- */
    fp = fopen("datos.txt", "r");

    if (fp == NULL)
        return 1;
    
    int c;
    printf("Lectura con fgetc:\n");

    while ((c = fgetc(fp)) != EOF)
    {
        putchar(c);
    }

    if (feof(fp))
        printf("\n[Fin de archivo detectado]\n");
    else if (ferror(fp))
        printf("\n[Error de lectura]\n");

    fclose(fp); // SIEMPRE cerrar

    /* ---- LECTURA POR LINEAS + PARSEO ---- */
    fp = fopen("datos.txt", "r");

    if (fp == NULL)
        return 1;

    char linea[100];
    int edad;
    float altura;

    printf("\nLectura con fgets + sscanf:\n");

    while(fgets(linea, sizeof(linea), fp) != NULL)
    {
        printf("Linea cruda: %s", linea);

        /* PARSEO SEGURO */
        if (sscanf(linea, "Edad: %d Altura: %f", &edad, &altura) == 2)
        {
            printf("-> Parseado: edad=%d altura=%.2f\n", edad, altura);
        }
    }

    if (feof(fp))
    {
        printf("Fin de archivo\n");
    }
    else if (ferror(fp))
    {
        printf("Error de lectura\n");
    }
    fclose(fp);

    return 0;
}
</code></pre>

<h2>Continúa Parte 2</h2>
</div>
</main>

<footer class="footer-nav">
  <div class="container">
  <a href="../teoria/bitwise.html" class="btn">Anterior</a>
  <a href="../teoria/abm.html" class="btn">Siguiente</a>
  </div>
</footer>

<script src="../js/prism.js"></script>
<script src="../js/script.js"></script>

</body>
</html>