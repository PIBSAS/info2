<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TEMA 4</title>
  <meta name="author" content="Luciano Rabassa"/>
  <meta name="created" content="2026-01-30T21:15:00"/>
  <meta name="AppVersion" content="15.0000"/>
  <meta name="Company" content="Luciano's tech"/>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/prism.css">
</head>
<body>

<header class="site-header">
  <p class="materia">Informática II</p>
</header>

<main>
  <div class="container">

<h1>Campos de bits - Bit fields</h1>

<h2>¿Qué es un campo de bits?</h2>
<p>Los campos de bit son una forma especial de declarar miembros de una estructura
donde, en vez de ocupar toda la dimensión del tipo (<strong><code>int</code></strong>, <strong><code>unsigned</code></strong>, etc),
se indica cuántos bits exactos ocupa el campo.</p>
    
<h2>¿Para qué sirven?</h2>
<p>Para empaquetar información y ahorrar memoria, o para representar flags y registros de hardware.</p>

<h3>Ejemplo:</h3>
<p><strong>Necesitamos guardar:</strong></p>
<ul>
    <li>Un estado que solo vale <b>0</b> o <b>1</b> => <b>1 bit</b>.</li>
    <li>Un número de <b>0</b> a <b>7</b> => <b>3 bits</b>.</li>
    <li>Un código de <b>0</b> a <b>15</b> => <b>4 bits</b>.</li>
</ul>
<p><strong>No tiene sentido gastar <b>3 int completos</b> para eso</strong></p>
    
<h3>Sintaxis</h3>

<p>La sintaxis SOLO EXISTE dentro de un <strong><code>struct</code></strong>.</p>

<pre><code class="language-c">tipo nombre_campo : cantidad_de_bits;</code></pre>

<h3>Ejemplo:</h3>

<pre><code class="language-c">
struct Ejemplo {
  unsigned campo1 : 1; // Campo : Cantidad de bits que ocupa
  unsigned campo2 : 3;
  unsigned campo3 : 4;
};
</code></pre>
<p><strong><em>IMPORTANTE:</em></strong></p>
<p><strong><code>cantidad_de_bits</code> debe ser una constante entera positiva.</strong></p>
<p><strong>Solo se permiten tipos enteros:</strong></p>
<ul>
    <li>int</li>
    <li>unsigned int</li>
    <li>signed int</li>
    <li>_Bool (desde C99)</li>
</ul>
<div class="nota">
    <p><strong>NO SE PUEDE USAR float, double, punteros, structs, etc.</strong></p>
</div>

<h3>Ejemplo simple:</h3>
<pre><code class="language-c">
struct flags {
  unsigned listo : 1;
  unsigned error : 1;
  unsigned prioridad : 2;
};
</code></pre>

<h4>Uso:</h4>
<pre><code class="language-c">
struct flags f = {1, 0, 3};

printf("listo = %u\n", f.listo);
printf("error = %u\n", f.error);
printf("prioridad = %u\n", f.prioridad);
</code></pre>

<h3>¿Qué sucede aquí?</h3>
<ul>
    <li><strong>listo</strong> ocupa 1 bit => Valores posibles: 0 o 1</li>
    <li><strong>error</strong> ocupa 1 bit => Valores posibles: 0 o 1</li>
    <li><strong>prioridad</strong> ocupa 2 bit => Valores posibles: 0 a 3</li>
</ul>

<h4>Si intentamos hacer:</h4>
<pre><code class="language-c">f.prioridad = 5; // (UB)</code></pre>

<div class="nota">
    <p>Comportamiento dependiente de la implementación (generalmente se truncan bits)</p>
</div>

<h3>¿Cuánta memoria ocupan?</h3>
<p><strong>Acá aparece la primera gran advertencia:</strong></p>
<ul>
    <li>El estándar NO garantiza el layout exacto en memoria.</li>
</ul>
<p><strong>Pero en la práctica:</strong></p>
<ul>
    <li>El compilador agrupa campos de bit en unidades de la dimensión del tipo base.</li>
    <li>Generalmente usa palabras(Word) de <b>1</b>, <b>2</b> o <b>4 bytes</b></li>
</ul>

<h3>Ejemplo:</h3>

<pre><code class="language-c">
struct A {
  unsigned a : 1;
  unsigned b : 1;
  unsigned c : 1;
};
</code></pre>
<p><strong>Aunque solo usa 3 bits:</strong></p>
<ul>
    <li>Probablemente <strong><code>sizeof(struct A)</code></strong> sea 4 bytes (si unsigned es de 4 bytes)</li>
</ul>
<div class="nota">
    <p><strong>Conclusión importante:</strong>
        Los campos de bit reducen espacio lógico, pero no siempre reducen <strong><code>sizeof</code></strong> como uno imagina.
    </p>
</div>

<h3>Campos de relleno (padding explícito)</h3>
<p>Podemos usar campos sin nombre para forzar alineación:</p>
<pre><code class="language-c">
struct B {
  unsigned a : 3;
  unsigned : 5; // Padding-Relleno
  unsigned b : 8;
};
</code></pre>
<p><strong>Esto:</strong></p>
<ul>
    <li>Descarta bits.</li>
    <li>Sirve para alinear a límites específicos.</li>
    <li>Es común en registros de hardware.</li>
</ul>

<h3>Campos de bit con signo:</h3>
<pre><code class="language-c">
struct C {
  signed valor : 3;
};
</code></pre>
<p><strong>Con 3 bits:</strong></p>
<ul>
    <li>Valores posibles (normalmente): -4 a +3</li>
</ul>
<p>El signo y representación depende del compilador(C<strong>omplemento a 2</strong> - <strong>Two's complement</strong> es lo común, pero el estándar no lo obliga).</p>
<p><strong>Regla práctica:</strong></p>
<ul>
    <li>Usamos <strong><code>unsigned</code></strong> siempre que podemos.</li>
    <li>Evitamos campos de bit con signo salvo que sea estrictamente necesario</li>
</ul>

<h3>Acceso y uso:</h3>
<p>Se acceden igual que cualquier miembro de estructura:</p>
<pre><code class="language-c">
f.error = 3;

if (f.listo) {
  printf("Todo Ok\n");
}
</code></pre>
<p><strong>NO SE PUEDE:</strong></p>
<ul>
    <li>Tomar la dirección de un campo de bit.</li>
</ul>
<pre><code class="language-c">unsigned *p = &f.error; // ERROR</code></pre>
<p>Porque no ocupa una dirección de memoria independiente.</p>
        
    
<h3>Pasaje a funciones</h3>    
<p>Los campos de bit no se pasan individualmente, pero si la estructura:</p>
<pre><code class="language-c">
void procesar(struct Flags f)
{
  if (f.error)
  {
      ...
  }
}
</code></pre>

<h4>O por puntero:</h4>
<pre><code class="language-c">
void limpiar(struct Flags *f)
{
  f -> error = 0;
}
</code></pre>

<h2>Diferencia con operaciones a nivel bit:</h2>
<p>Muchos confunden campos de bits con operadores bit a bit (<strong><code>& | ^ << >> </code></strong>).</p>

<h3>Campos de bit:</h3>
<ul>
    <li>Más legibles.</li>
    <li>Expresan intención.</li>
    <li>layout NO portable.</li>
    <li>NO direccionables.</li>
</ul>   

<h3>Operadores bit a bit:</h3>
<ul>
    <li>Totalmente controlables.</li>
    <li>Portables.</li>
    <li>Usados en protocolos y máscaras.</li>
    <li>Menos legibles.</li>
</ul>

<h3>Ejemplo equivalente con máscaras</h3>
<pre><code class="language-c">
# define LISTO (1 << 0)
# define ERROR (1 << 1)
# define PRIORIDAD (3 << 2)
</code></pre>

<h3>Cuando usarlos (y cuando no):</h3>
<ul>
    <li>Estamos modelando flags lógicos.</li>
    <li>Estamos representando registros de hardware.</li>
    <li>La portabilidad exacta no es crítica.</li>
    <li>El código es didáctico o interno.</li>
</ul>

<h3>No usarlos cuando:</h3>
<ul>
    <li>Necesitamos layout binario exacto.</li>
    <li>Escribimos archivos binarios.</li>
    <li>Hacemos comunicación de red.</li>
    <li>Necesitamos direcciones de los campos.</li>
</ul> 

<h3>Orden de los bits y portabilidad</h3>
<p>
    El orden de los bits dentro de la unidad de almacenamiento (LSB -> MSB o viceversa)
    es dependiente de la implementación y no está garantizado por el estándar.
</p>

<div class="nota">
    <p>
        Por convención, solemos declarar los bit-fields de LSB → MSB para mejorar la legibilidad,
        aunque el estándar no lo garantice.
    </p>
</div>

<h3>Resumen:</h3>
<ul>
    <li>Solo dentro de struct.</li>
    <li>Ocupan <strong>bits</strong>, no bytes.</li>
    <li><strong>Sintaxis: <code>tipo campo : bits;</code></strong></li>
    <li>No direccionables, ni portables.</li>
    <li>Layout dependiente del compilador.</li>
    <li>Muy útiles para flags y hardware.</li>
</ul>
<p>
    Los campos de bit definen el tamaño lógico de los datos <b>en bits</b>, 
    pero el almacenamiento físico y el tamaño medido por <strong><code>sizeof</code></strong> dependen 
    del empaquetado y alineación del compilador, 
    ya que la memoria es direccionable por bytes.
</p>

<h3>Extra: ¿Qué es alineación?</h3>

<p>Cada tipo de dato suele requerir que su dirección de memoria sea múltiplo de cierto valor.</p>
<p><strong>Ejemplo:</strong></p>
<pre><code class="language-c">
char => alineacion 1 byte.
short => alineacion 2 bytes.
int / unsigned => alineacion 4 bytes.
</code></pre>
<div class="nota">
    <p>El compilador inserta padding-relleno para cumplir eso.</p>
</div>

<h2 class="teoria">Teoría aplicada</h2>

<h3 class="make">Makefile:</h3>
<pre><code class="language-c">
CC = gcc
CFLAGS = -std=c11 -Wall -Wextra -pedantic

PROG = bitfields
OBJ = main.o

$(PROG): $(OBJ)
	$(CC) $(OBJ) -o $(PROG)

$(OBJ): main.c
	$(CC) $(CFLAGS) -c main.c

.PHONY: clean
clean:
	del $(OBJ) $(PROG).exe
</code></pre>

<h3 class="make">Código:</h3>
<pre><code class="language-c">
// gcc -std=c11 -Wall -Wextra -pedantic main.c -o bitfields
#include <stdio.h>

/* ---- bit-fields ----*/
struct Flags {
    unsigned listo : 1;
    unsigned error : 1;
    unsigned prioridad : 2;
};

/* ---- CAMPOS DE RELLENO ---- */
struct ConPadding {
    unsigned a : 3;
    unsigned : 5; // Padding de 5 bits
    unsigned b : 8;
};

/* ---- CAMPOS DE BIT CON SIGNO ---- */
struct SignedBits {
    signed valor : 3;
};

/* ---- PASAJE A FUNCIONES POR PUNTERO ---- */
void limpiar_error(struct Flags *f)
{
    f->error = 0;
}

int main(void)
{
    struct Flags f = {1, 0, 3}; // listo: bit en 1, error: bit en 0, prioridad: bit en 3

    printf("listo = %u\n", f.listo);
    printf("error = %u\n", f.error);
    printf("prioridad = %u\n", f.prioridad);

    /* ---- MEMORIA OCUPADA ---- */
    printf("sizeof(struct Flags) = %zu bytes\n", sizeof(struct Flags));

    /* ---- TRUNCAMIENTO DE BITS ---- */
    f.prioridad = 5; // Se espera que el compilador indique el fuera de rango -Woverflow
    printf("prioridad luego de asignar 5 = %u\n", f.prioridad); // Mostrara 1, porque prioridad tiene 2 bits, le estamos asignando 5 => 101 pero solo entran 2 bits 01, se conservan los LSB 01 = 1

    /* ---- CAMPOS DE RELLENO ---- */
    printf("sizeof(struct ConPadding) = %zu bytes\n", sizeof(struct ConPadding));

    /* ---- CAMPOS DE BIT CON SIGNO ---- */
    struct SignedBits s = { -1 };
    printf("valor = %d\n", s.valor); 

    /* ---- PASAJE A FUNCIONES POR PUNTERO ---- */
    f.error = 1;
    limpiar_error(&f); // Modificacion del campo de bit - bit-field
    printf("error luego de limpiar = %u\n", f.error);

    return 0;
} 
</code></pre>
</div>
</main>

<footer class="footer-nav">
  <div class="container">
  <a href="../teoria/union.html" class="btn">Anterior</a>
  <a href="../teoria/bitwise.html" class="btn">Siguiente</a>
  </div>
</footer>

<script src="../js/prism.js"></script>
<script src="../js/script.js"></script>

</body>
</html>