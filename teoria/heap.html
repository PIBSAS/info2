<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <link rel="icon" type="image/png" href="../img/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../img/favicon32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../img/favicon16.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TEMA 7</title>
  <meta name="author" content="Luciano Rabassa"/>
  <meta name="created" content="2026-02-01T10:41:00"/>
  <meta name="AppVersion" content="15.0000"/>
  <meta name="Company" content="Luciano's tech"/>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/prism.css">
</head>

<body>

<header class="site-header">
  <p class="materia">Informática II</p>
</header>

<main>
<div class="container">

<h1>Memoria dinámica - Heap</h1>

<h2>¿Qué es?</h2>

<h3>Es memoria que:</h3>
<ul>
    <li>Se solicita en tiempo de ejecución(<b>runtime</b>)</li>
    <li>Vive en una zona especial llamada <strong>heap</strong>.</li>
    <li>Permanece válida hasta que el programador la libere explícitamente.</li>
</ul>

<h3>En C, el programador es responsable de:</h3>
<ul>
    <li>Pedir memoria.</li>
    <li>Verificar que se asignó correctamente.</li>
    <li>Liberarla cuando ya no se usa.</li>
</ul>
    
<h2>¿Para qué se usa?</h2>

<h3>Se usa cuando:</h3>
<ul>
    <li>No conoces la dimensión de los datos al compilar</li>
    <li>La dimensión puede variar (arrays dinámicos)</li>
</ul>

<h3>Trabajamos con:</h3>
<ul>
    <li>Archivos - <strong><code>FILE *</code></strong></li>
    <li>Listas - Linked list, pilas - stack, colas - queue.</li>
    <li>Estructuras dinámicas - Dynamic structures</li>
    <li>Grandes volúmenes de datos.</li>
</ul>

<h3>Ejemplo:</h3>

<pre><code class="language-c">
int n;
scanf("%d",&n);
int v[n]; // NO estandar solo en algunos compiladores
</code></pre>
<p><strong>La forma correcta y portable:</strong></p>
<pre><code class="language-c">int *v = malloc(n * sizeof(int));</code></pre>
    
<h2>Asignación diámica de memoria:</h2>
<p>
    Se hace principalmente con funciones de <strong><code>&lt;stdlib.h&gt;</code></strong>, por lo cual deberemos incluirla
    cuando deseamos manejar la memoria dinámicamente.
</p>
        
<h3>Funciones:</h3>
<ul>
    <li><strong><code>malloc();</code></strong></li>
    <li><strong><code>calloc();</code></strong></li>
    <li><strong><code>realloc();</code></strong></li>
    <li><strong><code>free();</code></strong></li>
</ul>

<h2>Función malloc:</h2>

<h3>¿Qué es?:</h3>

<p><code>malloc</code> significa <b>memory allocation</b>.</p>

<ul>
    <li><strong>Es una función que:</strong>
        <ul>
            <li>Reserva un bloque de memoria en el <strong>heap</strong>.</li>
            <li>Devuelve la dirección inicial del bloque.</li>
            <li>NO inicializa la memoria.</li>
        </ul>
    </li>
</ul>
            
    
<h3>Sintaxis:</h3>

<pre><code class="language-c">void *malloc(size_t size);</code></pre>

<ul>
    <li><strong><code>size</code></strong> &rArr; Cantidad de bytes a reservar.</li>
</ul>
<ul>
    <li><strong>Retorna:</strong>
        <ul>
            <li>Un puntero a la memoria reservada.</li>
            <li><strong><code>NULL</code></strong> si no pudo reservar.</li>
        </ul>
    </li>
</ul>
      
<h3>¿Por qué devuelve <code>void *</code>?</h3>

<ul>
    <li><strong><code>malloc</code></strong> no sabe qué tipo de datos vamos a guardar.</li>
    <li>El <strong><code>void *</code></strong> puede convertirse a cualquier puntero.</li>
</ul>

<p><strong>En C no es obligatorio castear, pero suele pedirse:</strong></p>

<pre><code class="language-c">int *p = (int *) malloc(sizeof(int));</code></pre>
<pre><code class="language-c">int *v = malloc(n * sizeof(int)); // Para arrays</code></pre>
<pre><code class="language-c">vector = (int *) malloc((size_t)n * sizeof(int)); // Es una forma mas robusta, el compilador convierte <strong>n</strong> implícitamente a <strong><code>size_t</code></strong> lo que puede emitir warnings si <strong>n</strong> es negativo, de esta forma ya casteamos correctamente nosotros.</code></pre>


<h2>Verificación de error (OBLIGATORIO)</h2>

<p>Siempre hay que comprobar si <strong><code>malloc</code></strong> devolvió <strong><code>NULL</code></strong>:</p>

<pre><code class="language-c">
int *p = malloc(sizeof(int));

if (p == NULL)
{
    printf("Error: no se pudo asignar memoria\n");
    return 1;
}
</code></pre>
<div class="nota">
    <p><strong>No hacerlo es un error grave.</strong></p>
</div>


<h2>Acceso a la memoria asignada</h2>

<h3>Una vez asignada, se usa como cualquier puntero:</h3>

<pre><code class="language-c">
*p = 10;
printf("%d\n", *p);
</code></pre>

<h3>Para arrays dinámicos:</h3>
<pre><code class="language-c">v[i] = i * 2;</code></pre>
    
<h2>Liberación de memoria free</h2>

<p>Toda memoria solicitada con <strong><code>malloc</code></strong> DEBE liberarse:</p>
<pre><code class="language-c">
free(p);
p = NULL;
</code></pre>

<p><strong>Evita:</strong></p>
<ul>
    <li>Memory leaks.</li>
    <li>Dangling pointers.</li>
</ul>

<h3>Errores comunes con <strong><code>malloc</code></strong>:</h3>

<ul>
    <li>NO verificar <strong><code>NULL</code></strong>.</li>
    <li>Usar memoria sin asignar.</li>
    <li>Olvidar <strong><code>free</code></strong>.</li>
    <li>Liberar dos veces el mismo puntero.</li>
    <li>Acceder fuera del bloque reservado.</li>
</ul>


<h3>Ejemplo:</h3>

<pre><code class="language-c">
int *p;

p = (int *) malloc(sizeof(int)); // Pedimos memoria para el puntero p

if (p == NULL) // Verificamos que malloc no devolvio NULL
{
    printf("No se pudo asignar memoria\n");
    return 1;
}

*p = 25; // Pasamos por valor un dato a la direccion del puntero
printf("Valor: %d\n", *p);

free(p);
p = NULL; // Liberamos la memoria solicitada
</code></pre>


<h2>Dangling pointer - puntero colgado o suelto:</h2>

<p>
    Un puntero que sigue apuntando a una zona de memoria que ya fue liberada
    o que dejó de ser válida.
</p>
<p><strong>En otras palabras:</strong></p>
<ul>
    <li>El puntero existe.</li>
    <li>Tiene una dirección guardada.</li>
    <li>Pero esa memoria ya no nos pertenece porque fue liberada con <strong><code>free()</code></strong>.</li>
    <li>Usarlo es comportamiento indefinido (<b>UB</b>).</li>
</ul>

<h3>Ejemplo:</h3>

<pre><code class="language-c">
int *p = malloc(sizeof(int)); // Reservamos memoria
*p = 10;
free(p); // Liberamos del heap la memoria solicitada, dejando de ser valida
printf("%d\n", *p); // Error: p es un dangling pointer
</code></pre>


<h3>¿Cómo se evita?</h3>

<pre><code class="language-c">
int *p = malloc(sizeof(int)); // Reservamos memoria
*p = 10;
free(p); // Liberamos del heap la memoria solicitada, el puntero queda colgado (dangling)
p = NULL; // NULL no apunta a memoria valida
printf("%d\n", *p); // Acceder a *p cuando p == NULL es facil de detectar.
</code></pre>
<div class="nota">
    <p><strong>Asignar <strong><code>NULL</code></strong> invalida el puntero y evita su uso accidental.</strong></p>
</div>


<h2 class="teoria">Teoría aplicada</h2>

<h3 class="make">Makefile:</h3>
<pre><code class="language-c">
CC = gcc
CFLAGS = -std=c11 -Wall -Wextra -pedantic

PROG = dinamica
OBJ = main.o

$(PROG): $(OBJ)
	$(CC) $(OBJ) -o $(PROG)

$(OBJ): main.c
	$(CC) $(CFLAGS) -c main.c

.PHONY: clean
clean:
	del $(OBJ) $(PROG).exe
</code></pre>

<h3 class="make">Código:</h3>
<pre><code class="language-c">
// gcc -std=c11 -Wall -Wextra -pedantic main.c -o dinamica
#include <stdio.h>
#include <stdlib.h> // Se agrega la libreria estandar para trabajar con memoria dinamica

/*
     Las llaves auxiliares se utilizan para aislar los ejemplos,
     limitando el alcance de las variables
     y mostrar usos independientes de la memoria dinamica.
     Se pueden omitir.
*/
int main(void)
{
    /* ---- ASIGNACION DINAMICA DE UNA VARIABLE SIMPLE (int) ---- */
    {
        int *p;

        /* El casteo no es obligatorio en C, pero se usa con fines didacticos */
        p = (int *) malloc(sizeof(int)); // Pedimos memoria para el puntero p

        if (p == NULL) // Verificamos que malloc no devolvio NULL
        {
            printf("No se pudo asignar memoria\n");
            return 1;
        }

        *p = 25; // Pasamos por valor un dato a la direccion del puntero
        printf("Valor almacenado en *p = %d\n\n", *p);

        free(p); 
        p = NULL; // Liberamos la memoria solicitada
    }

    /* ---- ASIGNACION DINAMICA DE UN VECTOR DE ENTEROS ---- */
    {
        int *vector;
        int n, i;

        printf("Ingrese la cantidad de elementos: "); // Solicitamos n al usuario, para asi luego solicitar la memoria correspondiente
        // Validar scanf
        if (scanf("%d", &n) != 1 || n <= 0)
        {
            printf("Entrada invalida\n");
            return 1;
        }

        vector = (int *) malloc(n * sizeof(int)); // Pedimos memoria para el puntero vector
        
        if (vector == NULL) // Verificamos que malloc no devolvio NULL
        {
            printf("Error: no se pudo asignar memoria para el vector\n");
            return 1;
        }

        // Carga del vector
        for (i = 0; i < n; i++)
        {
            vector[i] = i + 1;
        }

        // Mostrar contenido
        printf("Contenido del vector:\n");
        for (i = 0; i < n; i++)
        {
            printf("vector[%d] = %d\n", i, vector[i]);
        }

        free(vector); // Liberamos la memoria solicitada del heap
        vector = NULL; // Evitamos dangling pointer
    }

    return 0;
}
</code></pre>
</div>
</main>


<footer class="footer-nav">
  <div class="container">
  <a href="../teoria/abm.html" class="btn">Anterior</a>
  <a href="../teoria/datastructure.html" class="btn">Siguiente</a>
  </div>
</footer>

<script src="../js/prism.js"></script>
<script src="../js/script.js"></script>

</body>

</html>

